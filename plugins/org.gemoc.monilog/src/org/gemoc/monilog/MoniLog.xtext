grammar org.gemoc.monilog.MoniLog with org.eclipse.xtext.common.Terminals

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

generate moniLog "http://www.gemoc.org/monilog/MoniLog"

Document:
	'package' name=QualifiedName
	imports+=Import*
	(events+=Event* & appenders+=Appender* & layouts+=Layout* & moniloggers+=MoniLogger*);

Import:
	'import' importedNamespace=QualifiedNameWithWildcard | 'import' alias=FileAlias;

FileAlias:
	filePath=STRING 'as' name=ID;

@Exported
Appender:
	LocalAppender | ExternalAppender;

LocalAppender:
	'appender' name=ID ('(' parameterDecl=ParameterDeclVarArgs ')')? '{'
		calls+=AppenderCall (';' calls+=AppenderCall)* ';'?
	'}';

ExternalAppender:
	'appender' name=ID ('(' parameterDecl=ParameterDeclVarArgs ')')?;

Layout:
	LocalLayout | ExternalLayout;

@Exported
LocalLayout:
	'layout' name=ID ('(' parameterDecl=ParameterDeclVarArgs ')')? '{'
		call=LayoutCall
	'}';

@Exported
ExternalLayout:
	'layout' name=ID ('(' parameterDecl=ParameterDeclVarArgs ')')?;

ParameterDeclVarArgs returns ParameterDecl:
	{ParameterDecl} (parameters+=Parameter (',' parameters+=Parameter)* (',' varArgs=Parameter '...')?)?;

ParameterDeclNoVarArgs returns ParameterDecl:
	{ParameterDecl} (parameters+=Parameter (',' parameters+=Parameter)*)?;

@Exported
MoniLogger:
	annotations+=MoniLoggerAnnotation*
	'monilogger' name=ID ('(' parameterDecl=ParameterDeclVarArgs ')')? ('[' level=LogLevel ']')? '{'
		'event' streamEvent=StreamEvent
		('conditions' '{' (conditions+=Condition) (';' conditions+=Condition)* ';'? '}')?
		'actions' '{' (actions+=Action) (';' actions+=Action)* ';'? '}'
	'}';

Parameter:
	name=ID;

@Exported
Event:
	({ASTEvent}
	'call' name=ID ('(' parameterDecl=ParameterDeclNoVarArgs ')')? '{'
		kind=ASTEventKind element=ASTReference
	'}') |
	({ComplexEvent} 'complex' name=ID ('(' (properties+=PropertyReference (',' properties+=PropertyReference)*)? ')')? '{'
		pattern=Alternation
	'}') |
	({UserEvent} 'custom' name=ID ('(' parameterDecl=ParameterDeclNoVarArgs ')')?);
//	'}') |
//	({ComplexEvent} 'complex' name=ID ('[' kind=TemporalPatternKind ']')? ('(' parameterDecl=ParameterDeclNoVarArgs ')')? '{'
//		pattern=TemporalPattern
//	'}') |
//	({UserEvent} 'custom' name=ID ('(' parameterDecl=ParameterDeclNoVarArgs ')')?);

ASTReference:
//	{CallableElementObjectReference} '$' target=[ecore::EObject|ID] |
	{CallableElementNamedReference} target=ID | {SourceRangeReference} 'l' line=INT '['from=INT ',' to=INT ']';

ASTEventKind:
	{BeforeASTEvent} 'before'| {AfterASTEvent} 'after';

Condition:
	expression=(Expression | LanguageValue);

Action:
	LanguageValue | AppenderCall
	| EmitEvent | MoniloggerCall
//	| SetVariable 
;

AppenderCall:
	appender=[Appender|QualifiedName] '.' 'call' ( '(' (args+=Expression (',' args+=Expression)*)? ')' )?;

LayoutCall:
	layout=[Layout|QualifiedName] '.' 'call' ( '(' args+=Expression (',' args+=Expression)* ')' )?;

EmitEvent:
	event=[UserEvent|ID] '.' 'emit' ('(' (args+=Expression (',' args+=Expression)*)? ')' )?;

//SetVariable:
//	'set' '(' variable=STRING ',' value=LanguageValue ')';

MoniloggerCall:
	{StartMoniLogger} monilogger=[MoniLogger|ID] '.' 'start' ( '(' (args+=Expression (',' args+=Expression)*)? ')' )? |
	{StopMoniLogger} monilogger=[MoniLogger|ID] '.' 'stop' ('(' ')')?;

LanguageValue:
	languageId=ID '(' value=(LanguageExpression | LanguageCall) ')';

LanguageExpression:
	expression=STRING;

LanguageCall:
	file=[FileAlias|ID] '.' fqn=QualifiedName ('(' (args+=Expression (',' args+=Expression)*)? ')' )?;

//====================================== COMPLEX EVENTS ======================================//

Alternation returns ComplexEventPattern:
	Concatenation ({Alternation.left=current} '|' right=Concatenation)*;

Concatenation returns ComplexEventPattern:
	Quantifier ({Concatenation.left=current} right=Quantifier)*;

Quantifier returns ComplexEventPattern:
	Grouping ({ZeroOrMore.pattern=current} '*' (reluctant?='?')? | {OneOrMore.pattern=current} '+' (reluctant?='?')? |
		{ZeroOrOne.pattern=current} '?' (reluctant?='?')? | {BetweenNAndM.pattern=current} '{' ( ',' max=INT | min=INT ',' max=INT | min=INT ',' ) '}' )?;

Grouping returns ComplexEventPattern:
	{Grouping} (absence?='not')? '(' pattern=Alternation ')' | StreamEvent;

StreamEvent:
	event=[Event|ID] ('[' propertyConstraints+=PropertyConstraint (',' propertyConstraints+=PropertyConstraint)* ']')?;

PropertyConstraint:
	{Empty} | {PropertyDefinition} property=Property ('=' '$' value=PropertyReference)? | {PropertyValue} '$' value=PropertyReference;
//	{Empty} | {PropertyDefinition} property=Property ('=' value=Expression)? | {PropertyValue} value=Expression;

Property:
	name=ID;

PropertyReference:
	property=[Property|ID];

//==================================== SIMPLE EXPRESSIONS ====================================//

Expression:
	ContractedIf;

ContractedIf returns SimpleExpression:
	Or ({ContractedIf.condition=current} '?' then=Or ':' else=Or)*;

Or returns SimpleExpression:
	And ({Or.left=current} op='||' right=And)*;

And returns SimpleExpression:
	Equality ({And.left=current} op='&&' right=Equality)*;

Equality returns SimpleExpression:
	Comparison ({Equality.left=current} op=('==' | '!=') right=Comparison)*;

Comparison returns SimpleExpression:
	PlusOrMinus ({Comparison.left=current} op=('>=' | '<=' | '>' | '<') right=PlusOrMinus)*;

PlusOrMinus returns SimpleExpression:
	MulOrDiv (({Plus.left=current} op='+' | {Minus.left=current} op='-') right=MulOrDiv)*;

MulOrDiv returns SimpleExpression:
	Modulo (({Mul.left=current} op='*' | {Div.Left=current} op='/') right=Modulo)*;

Modulo returns SimpleExpression:
	Primary ({Modulo.left=current} op='%' right=Primary)*;

Primary returns SimpleExpression:
	{Parenthesis} '(' expression=Expression ')' | {UnaryMinus} '-' expression=Primary | {Not} '!' expression=Primary |
	Atomic;

Atomic returns SimpleExpression:
	{IntConstant} value=INT | {RealConstant} value=REAL | {BoolConstant} (value?='true' | 'false') | {StringConstant} value=STRING |
	{VectorConstant} '[' values+=Expression (',' values+=Expression)* ']' | Ref | ArraySize | LanguageValue | LayoutCall;

Ref:
	'$' VarRef ({ArrayRef.array=current} '[' indices+=Expression (',' indices+=Expression)* ']' |
	{PropertyRef.object=current} '.' property=ID)*;

VarRef:
	{SpecVarNameReference} target=[ecore::EObject|ID] |
	{ContextVarReference} 'context' '(' target=ID ')';

ArraySize:
	'sizeOf' '(' array=Ref ')';

terminal REAL:
	INT '.' INT;

enum MoniLoggerAnnotation:
	inactive='@Inactive';

enum LogLevel:
	info='INFO' | config='CONFIG' | fine='FINE' | finer='FINER' |
	finest='FINEST' | severe='SEVERE' | warning='WARNING';

QualifiedName: ID ('.' ID)*;
QualifiedNameWithWildcard: QualifiedName '.*'?;