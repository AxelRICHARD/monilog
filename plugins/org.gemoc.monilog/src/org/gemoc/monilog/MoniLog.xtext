grammar org.gemoc.monilog.MoniLog with org.eclipse.xtext.common.Terminals

generate moniLog "http://www.gemoc.org/monilog/MoniLog"

Document:
	'package' name=QualifiedName
	imports+=Import*
	(events+=Event* & appenders+=Appender* & layouts+=Layout* & moniloggers+=MoniLogger*);

Import:
	'import' importedNamespace=QualifiedNameWithWildcard | 'import' alias=FileAlias;

FileAlias:
	filePath=STRING 'as' name=ID;

@Exported
Appender:
	LocalAppender | ExternalAppender;

LocalAppender:
	annotations+=AppenderAnnotation*
	'appender' name=ID ('(' parameterDecl=ParameterDeclVarArgs ')')? '{'
		calls+=AppenderCall (';' calls+=AppenderCall)* ';'?
	'}';

ExternalAppender:
	'appender' name=ID ('(' parameterDecl=ParameterDeclVarArgs ')')?;

Layout:
	LocalLayout | ExternalLayout;

@Exported
LocalLayout:
	'layout' name=ID ('(' parameterDecl=ParameterDeclVarArgs ')')? '{'
		call=LayoutCall
	'}';

@Exported
ExternalLayout:
	'layout' name=ID ('(' parameterDecl=ParameterDeclVarArgs ')')?;

ParameterDeclVarArgs returns ParameterDecl:
	{ParameterDecl}
	(parameters+=Parameter (',' parameters+=Parameter)* (',' varArgs=Parameter '...')?)?;

ParameterDeclNoVarArgs returns ParameterDecl:
	{ParameterDecl}
	(parameters+=Parameter (',' parameters+=Parameter)*)?;

@Exported
MoniLogger:
	annotations+=MoniLoggerAnnotation*
	'monilogger' name=ID ('(' parameterDecl=ParameterDeclVarArgs ')')? ('[' level=LogLevel ']')? '{'
		'event' streamEvent=StreamEvent
		('conditions' '{' (conditions+=Condition) (';' conditions+=Condition)* ';'? '}')?
		'actions' '{' (actions+=Action) (';' actions+=Action)* ';'? '}'
	'}';

Parameter:
	name=ID;

@Exported
Event:
	({ASTEvent}
	'call' name=ID ('(' parameterDecl=ParameterDeclNoVarArgs ')')? '{'
		kind=ASTEventKind ruleID=ID
	'}') |
	({ComplexEvent} 'complex' name=ID ('[' kind=TemporalPatternKind ']')? ('(' parameterDecl=ParameterDeclNoVarArgs ')')? '{'
		pattern=TemporalPattern
	'}') |
	({UserEvent} 'custom' name=ID ('(' parameterDecl=ParameterDeclNoVarArgs ')')?);

ASTEventKind:
	{BeforeASTEvent} 'before'| {AfterASTEvent} 'after';

Condition:
	expression=LanguageValue;

TemporalPattern:
	pattern=Pattern scope=Scope;

Pattern:
	{Existence} 'exists'? bound=BoundType? event=StreamEvent |
	{Universality} 'always' event=StreamEvent |
	{Absence} 'never' event=StreamEvent |
	{Precedence} predecessor=StreamEvent 'precedes' successor=StreamEvent |
	{Response} event=StreamEvent 'respondsTo' trigger=StreamEvent;

BoundType:
	ExactBound | LowerBound | UpperBound;

ExactBound:
	n=INT;

LowerBound:
	'atleast' n=INT;

UpperBound:
	'atmost' n=INT;

Scope:
	{Globally} ('globally')? |
	{After} 'after' lowerBound=StreamEvent | {Before} 'before' upperBound=StreamEvent |
	{Between} 'between' lowerBound=StreamEvent 'and' upperBound=StreamEvent |
	{AfterUntil} 'after' lowerBound=StreamEvent 'until' upperBound=StreamEvent;

Action:
	LanguageValue | AppenderCall | EmitEvent |
//	SetVariable |
	MoniloggerCall;

AppenderCall:
	appender=[Appender|QualifiedName] '.' 'call' ( '(' args+=Expression (',' args+=Expression)* ')' )?;

LayoutCall:
	layout=[Layout|QualifiedName] '.' 'call' ( '(' args+=Expression (',' args+=Expression)* ')' )?;

EmitEvent:
	event=[UserEvent|ID] '.' 'emit' ('(' args+=Expression (',' args+=Expression)* ')' )?;

//SetVariable:
//	'set' '(' variable=STRING ',' value=LanguageValue ')';

MoniloggerCall:
	{StartMoniLogger} monilogger=[MoniLogger|ID] '.' 'start' ( '(' args+=Expression (',' args+=Expression)* ')' )? |
	{StopMoniLogger} monilogger=[MoniLogger|ID] '.' 'stop';

StreamEvent:
	event=[Event|ID] ('(' values+=EmptyOrPropertyValue (',' values+=EmptyOrPropertyValue)* ')' )?;

EmptyOrPropertyValue:
	{Empty} | PropertyValue;

PropertyValue:
	id=ID ('=' value=Expression)? | value=LanguageValue;

Expression:
	ParameterReference | MoniLogExpression | LanguageValue | LayoutCall;

ParameterReference:
	parameter=[Parameter|ID];

MoniLogExpression:
	'{' expression=SimpleExpression '}';

LanguageValue:
	languageId=ID '(' value=(LanguageExpression | LanguageCall) ')';

LanguageExpression:
	expression=STRING;

LanguageCall:
	file=[FileAlias|ID] '.' fqn=QualifiedName ('(' args+=Expression (',' args+=Expression)* ')' )?;

//==================================== SIMPLE EXPRESSIONS ====================================//

SimpleExpression:
	ContractedIf;

ContractedIf returns SimpleExpression:
	Or ({ContractedIf.condition=current} '?' then=Or ':' else=Or)*;

Or returns SimpleExpression:
	And ({Or.left=current} op='||' right=And)*;

And returns SimpleExpression:
	Equality ({And.left=current} op='&&' right=Equality)*;

Equality returns SimpleExpression:
	Comparison ({Equality.left=current} op=('==' | '!=') right=Comparison)*;

Comparison returns SimpleExpression:
	PlusOrMinus ({Comparison.left=current} op=('>=' | '<=' | '>' | '<') right=PlusOrMinus)*;

PlusOrMinus returns SimpleExpression:
	MulOrDiv (({Plus.left=current} op='+' | {Minus.left=current} op='-') right=MulOrDiv)*;

MulOrDiv returns SimpleExpression:
	Modulo (({Mul.left=current} op='*' | {Div.Left=current} op='/') right=Modulo)*;

Modulo returns SimpleExpression:
	Primary ({Modulo.left=current} op='%' right=Primary)*;

Primary returns SimpleExpression:
	{Parenthesis} '(' expression=SimpleExpression ')' | {UnaryMinus} '-' expression=Primary | {Not} '!' expression=Primary |
	Atomic;

Atomic returns SimpleExpression:
	{IntConstant} value=INT | {RealConstant} value=REAL | {BoolConstant} (value?='true' | 'false') | {StringConstant} value=STRING |
	{VectorConstant} '[' values+=SimpleExpression (',' values+=SimpleExpression)* ']' | Ref | ArraySize;

Ref:
	SimpleVarRef ({ArrayRef.array=current} '[' indices+=SimpleExpression (',' indices+=SimpleExpression)* ']' |
	{PropertyRef.object=current} '.' property=ID)*;

SimpleVarRef:
	target=ID;

ArraySize:
	'sizeOf' '(' array=Ref ')';

terminal REAL:
	INT '.' INT;

enum MoniLoggerAnnotation:
	inactive='@Inactive';

enum AppenderAnnotation:
	async='@Async';

enum LogLevel:
	info='INFO' | config='CONFIG' | fine='FINE' | finer='FINER' |
	finest='FINEST' | severe='SEVERE' | warning='WARNING';

enum TemporalPatternKind:
	s='S'|v='V'|nS='nS'|nV='nV';

QualifiedName: ID ('.' ID)*;
QualifiedNameWithWildcard: QualifiedName '.*'?;