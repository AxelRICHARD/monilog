/*
 * generated by Xtext 2.22.0
 */
package org.gemoc.monilog.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.gemoc.monilog.moniLog4DSL.Absence;
import org.gemoc.monilog.moniLog4DSL.After;
import org.gemoc.monilog.moniLog4DSL.AfterEvent;
import org.gemoc.monilog.moniLog4DSL.AfterUntil;
import org.gemoc.monilog.moniLog4DSL.Append;
import org.gemoc.monilog.moniLog4DSL.Before;
import org.gemoc.monilog.moniLog4DSL.BeforeAfterEvent;
import org.gemoc.monilog.moniLog4DSL.BeforeEvent;
import org.gemoc.monilog.moniLog4DSL.Between;
import org.gemoc.monilog.moniLog4DSL.ConsoleAppender;
import org.gemoc.monilog.moniLog4DSL.DefaultLanguageExpression;
import org.gemoc.monilog.moniLog4DSL.Empty;
import org.gemoc.monilog.moniLog4DSL.ExactBound;
import org.gemoc.monilog.moniLog4DSL.Existence;
import org.gemoc.monilog.moniLog4DSL.ExplicitLanguageExpression;
import org.gemoc.monilog.moniLog4DSL.ExternalLayout;
import org.gemoc.monilog.moniLog4DSL.FileAppender;
import org.gemoc.monilog.moniLog4DSL.Globally;
import org.gemoc.monilog.moniLog4DSL.LanguageExpressionCondition;
import org.gemoc.monilog.moniLog4DSL.LowerBound;
import org.gemoc.monilog.moniLog4DSL.Model;
import org.gemoc.monilog.moniLog4DSL.MoniLog4DSLPackage;
import org.gemoc.monilog.moniLog4DSL.MoniLogSpec;
import org.gemoc.monilog.moniLog4DSL.Notify;
import org.gemoc.monilog.moniLog4DSL.Precedence;
import org.gemoc.monilog.moniLog4DSL.PropertyValue;
import org.gemoc.monilog.moniLog4DSL.Response;
import org.gemoc.monilog.moniLog4DSL.StreamAppender;
import org.gemoc.monilog.moniLog4DSL.StreamEvent;
import org.gemoc.monilog.moniLog4DSL.StringLayout;
import org.gemoc.monilog.moniLog4DSL.TemporalPattern;
import org.gemoc.monilog.moniLog4DSL.TemporalPropertyCondition;
import org.gemoc.monilog.moniLog4DSL.Universality;
import org.gemoc.monilog.moniLog4DSL.UpperBound;
import org.gemoc.monilog.services.MoniLog4DSLGrammarAccess;

@SuppressWarnings("all")
public class MoniLog4DSLSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private MoniLog4DSLGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == MoniLog4DSLPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case MoniLog4DSLPackage.ABSENCE:
				sequence_Pattern(context, (Absence) semanticObject); 
				return; 
			case MoniLog4DSLPackage.AFTER:
				sequence_Scope(context, (After) semanticObject); 
				return; 
			case MoniLog4DSLPackage.AFTER_EVENT:
				sequence_AfterEvent(context, (AfterEvent) semanticObject); 
				return; 
			case MoniLog4DSLPackage.AFTER_UNTIL:
				sequence_Scope(context, (AfterUntil) semanticObject); 
				return; 
			case MoniLog4DSLPackage.APPEND:
				sequence_Append(context, (Append) semanticObject); 
				return; 
			case MoniLog4DSLPackage.BEFORE:
				sequence_Scope(context, (Before) semanticObject); 
				return; 
			case MoniLog4DSLPackage.BEFORE_AFTER_EVENT:
				sequence_BeforeAfterEvent(context, (BeforeAfterEvent) semanticObject); 
				return; 
			case MoniLog4DSLPackage.BEFORE_EVENT:
				sequence_BeforeEvent(context, (BeforeEvent) semanticObject); 
				return; 
			case MoniLog4DSLPackage.BETWEEN:
				sequence_Scope(context, (Between) semanticObject); 
				return; 
			case MoniLog4DSLPackage.CONSOLE_APPENDER:
				sequence_ConsoleAppender(context, (ConsoleAppender) semanticObject); 
				return; 
			case MoniLog4DSLPackage.DEFAULT_LANGUAGE_EXPRESSION:
				sequence_LanguageExpression(context, (DefaultLanguageExpression) semanticObject); 
				return; 
			case MoniLog4DSLPackage.EMPTY:
				sequence_EmptyOrPropertyValue(context, (Empty) semanticObject); 
				return; 
			case MoniLog4DSLPackage.EXACT_BOUND:
				sequence_ExactBound(context, (ExactBound) semanticObject); 
				return; 
			case MoniLog4DSLPackage.EXISTENCE:
				sequence_Pattern(context, (Existence) semanticObject); 
				return; 
			case MoniLog4DSLPackage.EXPLICIT_LANGUAGE_EXPRESSION:
				sequence_LanguageExpression(context, (ExplicitLanguageExpression) semanticObject); 
				return; 
			case MoniLog4DSLPackage.EXTERNAL_LAYOUT:
				sequence_ExternalLayout(context, (ExternalLayout) semanticObject); 
				return; 
			case MoniLog4DSLPackage.FILE_APPENDER:
				sequence_FileAppender(context, (FileAppender) semanticObject); 
				return; 
			case MoniLog4DSLPackage.GLOBALLY:
				sequence_Scope(context, (Globally) semanticObject); 
				return; 
			case MoniLog4DSLPackage.LANGUAGE_EXPRESSION_CONDITION:
				sequence_Condition(context, (LanguageExpressionCondition) semanticObject); 
				return; 
			case MoniLog4DSLPackage.LOWER_BOUND:
				sequence_LowerBound(context, (LowerBound) semanticObject); 
				return; 
			case MoniLog4DSLPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case MoniLog4DSLPackage.MONI_LOG_SPEC:
				sequence_MoniLogSpec(context, (MoniLogSpec) semanticObject); 
				return; 
			case MoniLog4DSLPackage.NOTIFY:
				sequence_Action(context, (Notify) semanticObject); 
				return; 
			case MoniLog4DSLPackage.PRECEDENCE:
				sequence_Pattern(context, (Precedence) semanticObject); 
				return; 
			case MoniLog4DSLPackage.PROPERTY_VALUE:
				sequence_EmptyOrPropertyValue(context, (PropertyValue) semanticObject); 
				return; 
			case MoniLog4DSLPackage.RESPONSE:
				sequence_Pattern(context, (Response) semanticObject); 
				return; 
			case MoniLog4DSLPackage.STREAM_APPENDER:
				sequence_StreamAppender(context, (StreamAppender) semanticObject); 
				return; 
			case MoniLog4DSLPackage.STREAM_EVENT:
				sequence_StreamEvent(context, (StreamEvent) semanticObject); 
				return; 
			case MoniLog4DSLPackage.STRING_LAYOUT:
				sequence_StringLayout(context, (StringLayout) semanticObject); 
				return; 
			case MoniLog4DSLPackage.TEMPORAL_PATTERN:
				sequence_TemporalPattern(context, (TemporalPattern) semanticObject); 
				return; 
			case MoniLog4DSLPackage.TEMPORAL_PROPERTY_CONDITION:
				sequence_Condition(context, (TemporalPropertyCondition) semanticObject); 
				return; 
			case MoniLog4DSLPackage.UNIVERSALITY:
				sequence_Pattern(context, (Universality) semanticObject); 
				return; 
			case MoniLog4DSLPackage.UPPER_BOUND:
				sequence_UpperBound(context, (UpperBound) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Action returns Notify
	 *
	 * Constraint:
	 *     {Notify}
	 */
	protected void sequence_Action(ISerializationContext context, Notify semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Event returns AfterEvent
	 *     AfterEvent returns AfterEvent
	 *
	 * Constraint:
	 *     ((ruleID=ID | ruleID=STRING) limit=INT? (frequency=INT? limit=INT?)*)
	 */
	protected void sequence_AfterEvent(ISerializationContext context, AfterEvent semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Action returns Append
	 *     Append returns Append
	 *
	 * Constraint:
	 *     appender=Appender
	 */
	protected void sequence_Append(ISerializationContext context, Append semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MoniLog4DSLPackage.Literals.APPEND__APPENDER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MoniLog4DSLPackage.Literals.APPEND__APPENDER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAppendAccess().getAppenderAppenderParserRuleCall_1_0(), semanticObject.getAppender());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Event returns BeforeAfterEvent
	 *     BeforeAfterEvent returns BeforeAfterEvent
	 *
	 * Constraint:
	 *     ((ruleID=ID | ruleID=STRING) frequency=INT? (limit=INT? frequency=INT?)*)
	 */
	protected void sequence_BeforeAfterEvent(ISerializationContext context, BeforeAfterEvent semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Event returns BeforeEvent
	 *     BeforeEvent returns BeforeEvent
	 *
	 * Constraint:
	 *     ((ruleID=ID | ruleID=STRING) frequency=INT? (limit=INT? frequency=INT?)*)
	 */
	protected void sequence_BeforeEvent(ISerializationContext context, BeforeEvent semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Condition returns LanguageExpressionCondition
	 *
	 * Constraint:
	 *     expression=LanguageExpression
	 */
	protected void sequence_Condition(ISerializationContext context, LanguageExpressionCondition semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MoniLog4DSLPackage.Literals.LANGUAGE_EXPRESSION_CONDITION__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MoniLog4DSLPackage.Literals.LANGUAGE_EXPRESSION_CONDITION__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConditionAccess().getExpressionLanguageExpressionParserRuleCall_1_1_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Condition returns TemporalPropertyCondition
	 *
	 * Constraint:
	 *     (pattern=TemporalPattern kind=TemporalPropertyConditionKind?)
	 */
	protected void sequence_Condition(ISerializationContext context, TemporalPropertyCondition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Appender returns ConsoleAppender
	 *     ConsoleAppender returns ConsoleAppender
	 *
	 * Constraint:
	 *     layout=Layout
	 */
	protected void sequence_ConsoleAppender(ISerializationContext context, ConsoleAppender semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MoniLog4DSLPackage.Literals.CONSOLE_APPENDER__LAYOUT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MoniLog4DSLPackage.Literals.CONSOLE_APPENDER__LAYOUT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConsoleAppenderAccess().getLayoutLayoutParserRuleCall_2_0(), semanticObject.getLayout());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     EmptyOrPropertyValue returns Empty
	 *
	 * Constraint:
	 *     {Empty}
	 */
	protected void sequence_EmptyOrPropertyValue(ISerializationContext context, Empty semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EmptyOrPropertyValue returns PropertyValue
	 *
	 * Constraint:
	 *     (id=ID value=LanguageExpression?)
	 */
	protected void sequence_EmptyOrPropertyValue(ISerializationContext context, PropertyValue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BoundType returns ExactBound
	 *     ExactBound returns ExactBound
	 *
	 * Constraint:
	 *     n=INT
	 */
	protected void sequence_ExactBound(ISerializationContext context, ExactBound semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MoniLog4DSLPackage.Literals.BOUND_TYPE__N) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MoniLog4DSLPackage.Literals.BOUND_TYPE__N));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExactBoundAccess().getNINTTerminalRuleCall_0(), semanticObject.getN());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Layout returns ExternalLayout
	 *     ExternalLayout returns ExternalLayout
	 *
	 * Constraint:
	 *     (path=FQN values+=LanguageExpression*)
	 */
	protected void sequence_ExternalLayout(ISerializationContext context, ExternalLayout semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Appender returns FileAppender
	 *     FileAppender returns FileAppender
	 *
	 * Constraint:
	 *     (filename=STRING layout=Layout)
	 */
	protected void sequence_FileAppender(ISerializationContext context, FileAppender semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MoniLog4DSLPackage.Literals.FILE_APPENDER__FILENAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MoniLog4DSLPackage.Literals.FILE_APPENDER__FILENAME));
			if (transientValues.isValueTransient(semanticObject, MoniLog4DSLPackage.Literals.FILE_APPENDER__LAYOUT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MoniLog4DSLPackage.Literals.FILE_APPENDER__LAYOUT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFileAppenderAccess().getFilenameSTRINGTerminalRuleCall_2_0(), semanticObject.getFilename());
		feeder.accept(grammarAccess.getFileAppenderAccess().getLayoutLayoutParserRuleCall_4_0(), semanticObject.getLayout());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     LanguageExpression returns DefaultLanguageExpression
	 *
	 * Constraint:
	 *     expression=STRING
	 */
	protected void sequence_LanguageExpression(ISerializationContext context, DefaultLanguageExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MoniLog4DSLPackage.Literals.LANGUAGE_EXPRESSION__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MoniLog4DSLPackage.Literals.LANGUAGE_EXPRESSION__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLanguageExpressionAccess().getExpressionSTRINGTerminalRuleCall_1_1_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     LanguageExpression returns ExplicitLanguageExpression
	 *
	 * Constraint:
	 *     ((languageId=ID | languageId=STRING) expression=STRING)
	 */
	protected void sequence_LanguageExpression(ISerializationContext context, ExplicitLanguageExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BoundType returns LowerBound
	 *     LowerBound returns LowerBound
	 *
	 * Constraint:
	 *     n=INT
	 */
	protected void sequence_LowerBound(ISerializationContext context, LowerBound semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MoniLog4DSLPackage.Literals.BOUND_TYPE__N) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MoniLog4DSLPackage.Literals.BOUND_TYPE__N));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLowerBoundAccess().getNINTTerminalRuleCall_1_0(), semanticObject.getN());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Model returns Model
	 *
	 * Constraint:
	 *     ((defaultLanguageID=ID | defaultLanguageID=STRING)? moniLogSpecs+=MoniLogSpec+)
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MoniLogSpec returns MoniLogSpec
	 *
	 * Constraint:
	 *     (
	 *         name=STRING? 
	 *         level=LogLevel? 
	 *         (events+=Event events+=Event*)? 
	 *         (conditions+=Condition conditions+=Condition*)? 
	 *         actions+=Action 
	 *         actions+=Action*
	 *     )
	 */
	protected void sequence_MoniLogSpec(ISerializationContext context, MoniLogSpec semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Pattern returns Absence
	 *
	 * Constraint:
	 *     event=StreamEvent
	 */
	protected void sequence_Pattern(ISerializationContext context, Absence semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MoniLog4DSLPackage.Literals.ABSENCE__EVENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MoniLog4DSLPackage.Literals.ABSENCE__EVENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPatternAccess().getEventStreamEventParserRuleCall_2_2_0(), semanticObject.getEvent());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Pattern returns Existence
	 *
	 * Constraint:
	 *     (bound=BoundType event=StreamEvent)
	 */
	protected void sequence_Pattern(ISerializationContext context, Existence semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MoniLog4DSLPackage.Literals.EXISTENCE__BOUND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MoniLog4DSLPackage.Literals.EXISTENCE__BOUND));
			if (transientValues.isValueTransient(semanticObject, MoniLog4DSLPackage.Literals.EXISTENCE__EVENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MoniLog4DSLPackage.Literals.EXISTENCE__EVENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPatternAccess().getBoundBoundTypeParserRuleCall_1_2_0(), semanticObject.getBound());
		feeder.accept(grammarAccess.getPatternAccess().getEventStreamEventParserRuleCall_1_3_0(), semanticObject.getEvent());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Pattern returns Precedence
	 *
	 * Constraint:
	 *     (predecessor=StreamEvent successor=StreamEvent)
	 */
	protected void sequence_Pattern(ISerializationContext context, Precedence semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MoniLog4DSLPackage.Literals.PRECEDENCE__PREDECESSOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MoniLog4DSLPackage.Literals.PRECEDENCE__PREDECESSOR));
			if (transientValues.isValueTransient(semanticObject, MoniLog4DSLPackage.Literals.PRECEDENCE__SUCCESSOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MoniLog4DSLPackage.Literals.PRECEDENCE__SUCCESSOR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPatternAccess().getPredecessorStreamEventParserRuleCall_3_1_0(), semanticObject.getPredecessor());
		feeder.accept(grammarAccess.getPatternAccess().getSuccessorStreamEventParserRuleCall_3_3_0(), semanticObject.getSuccessor());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Pattern returns Response
	 *
	 * Constraint:
	 *     (event=StreamEvent trigger=StreamEvent)
	 */
	protected void sequence_Pattern(ISerializationContext context, Response semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MoniLog4DSLPackage.Literals.RESPONSE__EVENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MoniLog4DSLPackage.Literals.RESPONSE__EVENT));
			if (transientValues.isValueTransient(semanticObject, MoniLog4DSLPackage.Literals.RESPONSE__TRIGGER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MoniLog4DSLPackage.Literals.RESPONSE__TRIGGER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPatternAccess().getEventStreamEventParserRuleCall_4_1_0(), semanticObject.getEvent());
		feeder.accept(grammarAccess.getPatternAccess().getTriggerStreamEventParserRuleCall_4_3_0(), semanticObject.getTrigger());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Pattern returns Universality
	 *
	 * Constraint:
	 *     event=StreamEvent
	 */
	protected void sequence_Pattern(ISerializationContext context, Universality semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MoniLog4DSLPackage.Literals.UNIVERSALITY__EVENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MoniLog4DSLPackage.Literals.UNIVERSALITY__EVENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPatternAccess().getEventStreamEventParserRuleCall_0_2_0(), semanticObject.getEvent());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Scope returns After
	 *
	 * Constraint:
	 *     lowerBound=StreamEvent
	 */
	protected void sequence_Scope(ISerializationContext context, After semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MoniLog4DSLPackage.Literals.AFTER__LOWER_BOUND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MoniLog4DSLPackage.Literals.AFTER__LOWER_BOUND));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getScopeAccess().getLowerBoundStreamEventParserRuleCall_1_2_0(), semanticObject.getLowerBound());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Scope returns AfterUntil
	 *
	 * Constraint:
	 *     (lowerBound=StreamEvent upperBound=StreamEvent)
	 */
	protected void sequence_Scope(ISerializationContext context, AfterUntil semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MoniLog4DSLPackage.Literals.AFTER_UNTIL__LOWER_BOUND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MoniLog4DSLPackage.Literals.AFTER_UNTIL__LOWER_BOUND));
			if (transientValues.isValueTransient(semanticObject, MoniLog4DSLPackage.Literals.AFTER_UNTIL__UPPER_BOUND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MoniLog4DSLPackage.Literals.AFTER_UNTIL__UPPER_BOUND));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getScopeAccess().getLowerBoundStreamEventParserRuleCall_4_2_0(), semanticObject.getLowerBound());
		feeder.accept(grammarAccess.getScopeAccess().getUpperBoundStreamEventParserRuleCall_4_4_0(), semanticObject.getUpperBound());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Scope returns Before
	 *
	 * Constraint:
	 *     upperBound=StreamEvent
	 */
	protected void sequence_Scope(ISerializationContext context, Before semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MoniLog4DSLPackage.Literals.BEFORE__UPPER_BOUND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MoniLog4DSLPackage.Literals.BEFORE__UPPER_BOUND));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getScopeAccess().getUpperBoundStreamEventParserRuleCall_2_2_0(), semanticObject.getUpperBound());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Scope returns Between
	 *
	 * Constraint:
	 *     (lowerBound=StreamEvent upperBound=StreamEvent)
	 */
	protected void sequence_Scope(ISerializationContext context, Between semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MoniLog4DSLPackage.Literals.BETWEEN__LOWER_BOUND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MoniLog4DSLPackage.Literals.BETWEEN__LOWER_BOUND));
			if (transientValues.isValueTransient(semanticObject, MoniLog4DSLPackage.Literals.BETWEEN__UPPER_BOUND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MoniLog4DSLPackage.Literals.BETWEEN__UPPER_BOUND));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getScopeAccess().getLowerBoundStreamEventParserRuleCall_3_2_0(), semanticObject.getLowerBound());
		feeder.accept(grammarAccess.getScopeAccess().getUpperBoundStreamEventParserRuleCall_3_4_0(), semanticObject.getUpperBound());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Scope returns Globally
	 *
	 * Constraint:
	 *     {Globally}
	 */
	protected void sequence_Scope(ISerializationContext context, Globally semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Appender returns StreamAppender
	 *     StreamAppender returns StreamAppender
	 *
	 * Constraint:
	 *     ((event=ID | event=STRING) (values+=LanguageExpression values+=LanguageExpression*)?)
	 */
	protected void sequence_StreamAppender(ISerializationContext context, StreamAppender semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     StreamEvent returns StreamEvent
	 *
	 * Constraint:
	 *     ((eventId=ID | eventId=STRING) (values+=EmptyOrPropertyValue values+=EmptyOrPropertyValue*)?)
	 */
	protected void sequence_StreamEvent(ISerializationContext context, StreamEvent semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Layout returns StringLayout
	 *     StringLayout returns StringLayout
	 *
	 * Constraint:
	 *     (formatString=STRING values+=LanguageExpression*)
	 */
	protected void sequence_StringLayout(ISerializationContext context, StringLayout semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TemporalPattern returns TemporalPattern
	 *
	 * Constraint:
	 *     (pattern=Pattern scope=Scope)
	 */
	protected void sequence_TemporalPattern(ISerializationContext context, TemporalPattern semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MoniLog4DSLPackage.Literals.TEMPORAL_PATTERN__PATTERN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MoniLog4DSLPackage.Literals.TEMPORAL_PATTERN__PATTERN));
			if (transientValues.isValueTransient(semanticObject, MoniLog4DSLPackage.Literals.TEMPORAL_PATTERN__SCOPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MoniLog4DSLPackage.Literals.TEMPORAL_PATTERN__SCOPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTemporalPatternAccess().getPatternPatternParserRuleCall_0_0(), semanticObject.getPattern());
		feeder.accept(grammarAccess.getTemporalPatternAccess().getScopeScopeParserRuleCall_1_0(), semanticObject.getScope());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     BoundType returns UpperBound
	 *     UpperBound returns UpperBound
	 *
	 * Constraint:
	 *     n=INT
	 */
	protected void sequence_UpperBound(ISerializationContext context, UpperBound semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MoniLog4DSLPackage.Literals.BOUND_TYPE__N) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MoniLog4DSLPackage.Literals.BOUND_TYPE__N));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUpperBoundAccess().getNINTTerminalRuleCall_1_0(), semanticObject.getN());
		feeder.finish();
	}
	
	
}
