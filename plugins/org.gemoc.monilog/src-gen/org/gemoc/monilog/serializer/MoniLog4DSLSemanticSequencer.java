/*
 * generated by Xtext 2.22.0
 */
package org.gemoc.monilog.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.gemoc.monilog.moniLog4DSL.ASTEvent;
import org.gemoc.monilog.moniLog4DSL.Absence;
import org.gemoc.monilog.moniLog4DSL.After;
import org.gemoc.monilog.moniLog4DSL.AfterUntil;
import org.gemoc.monilog.moniLog4DSL.AppenderCall;
import org.gemoc.monilog.moniLog4DSL.AppenderRef;
import org.gemoc.monilog.moniLog4DSL.Before;
import org.gemoc.monilog.moniLog4DSL.Between;
import org.gemoc.monilog.moniLog4DSL.ComplexEvent;
import org.gemoc.monilog.moniLog4DSL.DefaultLanguageExpression;
import org.gemoc.monilog.moniLog4DSL.Document;
import org.gemoc.monilog.moniLog4DSL.EmitEvent;
import org.gemoc.monilog.moniLog4DSL.Empty;
import org.gemoc.monilog.moniLog4DSL.ExactBound;
import org.gemoc.monilog.moniLog4DSL.Existence;
import org.gemoc.monilog.moniLog4DSL.ExplicitLanguageExpression;
import org.gemoc.monilog.moniLog4DSL.ExternalAppender;
import org.gemoc.monilog.moniLog4DSL.ExternalLayout;
import org.gemoc.monilog.moniLog4DSL.Globally;
import org.gemoc.monilog.moniLog4DSL.LanguageExpressionCondition;
import org.gemoc.monilog.moniLog4DSL.LayoutCall;
import org.gemoc.monilog.moniLog4DSL.LayoutRef;
import org.gemoc.monilog.moniLog4DSL.LocalAppender;
import org.gemoc.monilog.moniLog4DSL.LocalLayout;
import org.gemoc.monilog.moniLog4DSL.LowerBound;
import org.gemoc.monilog.moniLog4DSL.MoniLog4DSLPackage;
import org.gemoc.monilog.moniLog4DSL.MoniLogger;
import org.gemoc.monilog.moniLog4DSL.ParameterReference;
import org.gemoc.monilog.moniLog4DSL.Precedence;
import org.gemoc.monilog.moniLog4DSL.PropertyValue;
import org.gemoc.monilog.moniLog4DSL.Response;
import org.gemoc.monilog.moniLog4DSL.StartMoniLogger;
import org.gemoc.monilog.moniLog4DSL.StopMoniLogger;
import org.gemoc.monilog.moniLog4DSL.StreamEvent;
import org.gemoc.monilog.moniLog4DSL.TemporalPattern;
import org.gemoc.monilog.moniLog4DSL.Universality;
import org.gemoc.monilog.moniLog4DSL.UpperBound;
import org.gemoc.monilog.moniLog4DSL.UserEvent;
import org.gemoc.monilog.services.MoniLog4DSLGrammarAccess;

@SuppressWarnings("all")
public class MoniLog4DSLSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private MoniLog4DSLGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == MoniLog4DSLPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case MoniLog4DSLPackage.AST_EVENT:
				sequence_ASTEvent(context, (ASTEvent) semanticObject); 
				return; 
			case MoniLog4DSLPackage.ABSENCE:
				sequence_Pattern(context, (Absence) semanticObject); 
				return; 
			case MoniLog4DSLPackage.AFTER:
				sequence_Scope(context, (After) semanticObject); 
				return; 
			case MoniLog4DSLPackage.AFTER_UNTIL:
				sequence_Scope(context, (AfterUntil) semanticObject); 
				return; 
			case MoniLog4DSLPackage.APPENDER_CALL:
				sequence_AppenderCall(context, (AppenderCall) semanticObject); 
				return; 
			case MoniLog4DSLPackage.APPENDER_REF:
				sequence_AppenderRef(context, (AppenderRef) semanticObject); 
				return; 
			case MoniLog4DSLPackage.BEFORE:
				sequence_Scope(context, (Before) semanticObject); 
				return; 
			case MoniLog4DSLPackage.BETWEEN:
				sequence_Scope(context, (Between) semanticObject); 
				return; 
			case MoniLog4DSLPackage.COMPLEX_EVENT:
				sequence_ComplexEvent(context, (ComplexEvent) semanticObject); 
				return; 
			case MoniLog4DSLPackage.DEFAULT_LANGUAGE_EXPRESSION:
				sequence_LanguageExpression(context, (DefaultLanguageExpression) semanticObject); 
				return; 
			case MoniLog4DSLPackage.DOCUMENT:
				sequence_Document(context, (Document) semanticObject); 
				return; 
			case MoniLog4DSLPackage.EMIT_EVENT:
				sequence_EmitEvent(context, (EmitEvent) semanticObject); 
				return; 
			case MoniLog4DSLPackage.EMPTY:
				sequence_EmptyOrPropertyValue(context, (Empty) semanticObject); 
				return; 
			case MoniLog4DSLPackage.EXACT_BOUND:
				sequence_ExactBound(context, (ExactBound) semanticObject); 
				return; 
			case MoniLog4DSLPackage.EXISTENCE:
				sequence_Pattern(context, (Existence) semanticObject); 
				return; 
			case MoniLog4DSLPackage.EXPLICIT_LANGUAGE_EXPRESSION:
				sequence_LanguageExpression(context, (ExplicitLanguageExpression) semanticObject); 
				return; 
			case MoniLog4DSLPackage.EXTERNAL_APPENDER:
				sequence_ExternalAppender(context, (ExternalAppender) semanticObject); 
				return; 
			case MoniLog4DSLPackage.EXTERNAL_LAYOUT:
				sequence_ExternalLayout(context, (ExternalLayout) semanticObject); 
				return; 
			case MoniLog4DSLPackage.GLOBALLY:
				sequence_Scope(context, (Globally) semanticObject); 
				return; 
			case MoniLog4DSLPackage.LANGUAGE_EXPRESSION_CONDITION:
				sequence_Condition(context, (LanguageExpressionCondition) semanticObject); 
				return; 
			case MoniLog4DSLPackage.LAYOUT_CALL:
				sequence_LayoutCall(context, (LayoutCall) semanticObject); 
				return; 
			case MoniLog4DSLPackage.LAYOUT_REF:
				sequence_LayoutRef(context, (LayoutRef) semanticObject); 
				return; 
			case MoniLog4DSLPackage.LOCAL_APPENDER:
				sequence_LocalAppender(context, (LocalAppender) semanticObject); 
				return; 
			case MoniLog4DSLPackage.LOCAL_LAYOUT:
				sequence_LocalLayout(context, (LocalLayout) semanticObject); 
				return; 
			case MoniLog4DSLPackage.LOWER_BOUND:
				sequence_LowerBound(context, (LowerBound) semanticObject); 
				return; 
			case MoniLog4DSLPackage.MONI_LOGGER:
				sequence_MoniLogger(context, (MoniLogger) semanticObject); 
				return; 
			case MoniLog4DSLPackage.PARAMETER:
				sequence_Parameter(context, (org.gemoc.monilog.moniLog4DSL.Parameter) semanticObject); 
				return; 
			case MoniLog4DSLPackage.PARAMETER_REFERENCE:
				sequence_ParameterReference(context, (ParameterReference) semanticObject); 
				return; 
			case MoniLog4DSLPackage.PRECEDENCE:
				sequence_Pattern(context, (Precedence) semanticObject); 
				return; 
			case MoniLog4DSLPackage.PROPERTY_VALUE:
				sequence_EmptyOrPropertyValue(context, (PropertyValue) semanticObject); 
				return; 
			case MoniLog4DSLPackage.RESPONSE:
				sequence_Pattern(context, (Response) semanticObject); 
				return; 
			case MoniLog4DSLPackage.START_MONI_LOGGER:
				sequence_MoniLoggerCall(context, (StartMoniLogger) semanticObject); 
				return; 
			case MoniLog4DSLPackage.STOP_MONI_LOGGER:
				sequence_MoniLoggerCall(context, (StopMoniLogger) semanticObject); 
				return; 
			case MoniLog4DSLPackage.STREAM_EVENT:
				sequence_StreamEvent(context, (StreamEvent) semanticObject); 
				return; 
			case MoniLog4DSLPackage.TEMPORAL_PATTERN:
				sequence_TemporalPattern(context, (TemporalPattern) semanticObject); 
				return; 
			case MoniLog4DSLPackage.UNIVERSALITY:
				sequence_Pattern(context, (Universality) semanticObject); 
				return; 
			case MoniLog4DSLPackage.UPPER_BOUND:
				sequence_UpperBound(context, (UpperBound) semanticObject); 
				return; 
			case MoniLog4DSLPackage.USER_EVENT:
				sequence_UserEvent(context, (UserEvent) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Event returns ASTEvent
	 *     ASTEvent returns ASTEvent
	 *
	 * Constraint:
	 *     (name=ID (before?='before' | after?='after')* ruleID=ID)
	 */
	protected void sequence_ASTEvent(ISerializationContext context, ASTEvent semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Action returns AppenderCall
	 *     AppenderCall returns AppenderCall
	 *
	 * Constraint:
	 *     (appender=AppenderRef (args+=AppenderCallArgument args+=AppenderCallArgument*)?)
	 */
	protected void sequence_AppenderCall(ISerializationContext context, AppenderCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AppenderRef returns AppenderRef
	 *
	 * Constraint:
	 *     appender=[Appender|FQN]
	 */
	protected void sequence_AppenderRef(ISerializationContext context, AppenderRef semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MoniLog4DSLPackage.Literals.APPENDER_REF__APPENDER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MoniLog4DSLPackage.Literals.APPENDER_REF__APPENDER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAppenderRefAccess().getAppenderAppenderFQNParserRuleCall_0_1(), semanticObject.eGet(MoniLog4DSLPackage.Literals.APPENDER_REF__APPENDER, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Event returns ComplexEvent
	 *     ComplexEvent returns ComplexEvent
	 *
	 * Constraint:
	 *     (name=ID kind=TemporalPatternKind? pattern=TemporalPattern)
	 */
	protected void sequence_ComplexEvent(ISerializationContext context, ComplexEvent semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Condition returns LanguageExpressionCondition
	 *
	 * Constraint:
	 *     expression=LanguageExpression
	 */
	protected void sequence_Condition(ISerializationContext context, LanguageExpressionCondition semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MoniLog4DSLPackage.Literals.LANGUAGE_EXPRESSION_CONDITION__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MoniLog4DSLPackage.Literals.LANGUAGE_EXPRESSION_CONDITION__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConditionAccess().getExpressionLanguageExpressionParserRuleCall_1_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Document returns Document
	 *
	 * Constraint:
	 *     (
	 *         defaultLanguageID=ID | 
	 *         ((defaultLanguageID=ID | defaultLanguageID=STRING)? (events+=Event | appenders+=Appender | layouts+=Layout | moniLogSpecs+=MoniLogger)+) | 
	 *         defaultLanguageID=STRING
	 *     )?
	 */
	protected void sequence_Document(ISerializationContext context, Document semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Action returns EmitEvent
	 *     EmitEvent returns EmitEvent
	 *
	 * Constraint:
	 *     (event=[Event|ID] (args+=Expression args+=Expression*)?)
	 */
	protected void sequence_EmitEvent(ISerializationContext context, EmitEvent semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EmptyOrPropertyValue returns Empty
	 *
	 * Constraint:
	 *     {Empty}
	 */
	protected void sequence_EmptyOrPropertyValue(ISerializationContext context, Empty semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EmptyOrPropertyValue returns PropertyValue
	 *
	 * Constraint:
	 *     (id=ID value=Expression?)
	 */
	protected void sequence_EmptyOrPropertyValue(ISerializationContext context, PropertyValue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BoundType returns ExactBound
	 *     ExactBound returns ExactBound
	 *
	 * Constraint:
	 *     n=INT
	 */
	protected void sequence_ExactBound(ISerializationContext context, ExactBound semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MoniLog4DSLPackage.Literals.BOUND_TYPE__N) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MoniLog4DSLPackage.Literals.BOUND_TYPE__N));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExactBoundAccess().getNINTTerminalRuleCall_0(), semanticObject.getN());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Appender returns ExternalAppender
	 *     ExternalAppender returns ExternalAppender
	 *
	 * Constraint:
	 *     (name=FQN (parameters+=Parameter parameters+=Parameter*)?)
	 */
	protected void sequence_ExternalAppender(ISerializationContext context, ExternalAppender semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Layout returns ExternalLayout
	 *     ExternalLayout returns ExternalLayout
	 *
	 * Constraint:
	 *     (name=FQN (parameters+=Parameter parameters+=Parameter*)?)
	 */
	protected void sequence_ExternalLayout(ISerializationContext context, ExternalLayout semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Action returns DefaultLanguageExpression
	 *     AppenderCallArgument returns DefaultLanguageExpression
	 *     Expression returns DefaultLanguageExpression
	 *     LanguageExpression returns DefaultLanguageExpression
	 *
	 * Constraint:
	 *     expression=STRING
	 */
	protected void sequence_LanguageExpression(ISerializationContext context, DefaultLanguageExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MoniLog4DSLPackage.Literals.LANGUAGE_EXPRESSION__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MoniLog4DSLPackage.Literals.LANGUAGE_EXPRESSION__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLanguageExpressionAccess().getExpressionSTRINGTerminalRuleCall_1_1_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Action returns ExplicitLanguageExpression
	 *     AppenderCallArgument returns ExplicitLanguageExpression
	 *     Expression returns ExplicitLanguageExpression
	 *     LanguageExpression returns ExplicitLanguageExpression
	 *
	 * Constraint:
	 *     (languageId=ID expression=STRING)
	 */
	protected void sequence_LanguageExpression(ISerializationContext context, ExplicitLanguageExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MoniLog4DSLPackage.Literals.EXPLICIT_LANGUAGE_EXPRESSION__LANGUAGE_ID) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MoniLog4DSLPackage.Literals.EXPLICIT_LANGUAGE_EXPRESSION__LANGUAGE_ID));
			if (transientValues.isValueTransient(semanticObject, MoniLog4DSLPackage.Literals.LANGUAGE_EXPRESSION__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MoniLog4DSLPackage.Literals.LANGUAGE_EXPRESSION__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLanguageExpressionAccess().getLanguageIdIDTerminalRuleCall_0_1_0(), semanticObject.getLanguageId());
		feeder.accept(grammarAccess.getLanguageExpressionAccess().getExpressionSTRINGTerminalRuleCall_0_3_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AppenderCallArgument returns LayoutCall
	 *     LayoutCall returns LayoutCall
	 *
	 * Constraint:
	 *     (layout=LayoutRef (args+=Expression args+=Expression*)?)
	 */
	protected void sequence_LayoutCall(ISerializationContext context, LayoutCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LayoutRef returns LayoutRef
	 *
	 * Constraint:
	 *     layout=[Layout|FQN]
	 */
	protected void sequence_LayoutRef(ISerializationContext context, LayoutRef semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MoniLog4DSLPackage.Literals.LAYOUT_REF__LAYOUT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MoniLog4DSLPackage.Literals.LAYOUT_REF__LAYOUT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLayoutRefAccess().getLayoutLayoutFQNParserRuleCall_0_1(), semanticObject.eGet(MoniLog4DSLPackage.Literals.LAYOUT_REF__LAYOUT, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Appender returns LocalAppender
	 *     LocalAppender returns LocalAppender
	 *
	 * Constraint:
	 *     (annotations+=AppenderAnnotation* name=ID (parameters+=Parameter parameters+=Parameter*)? calls+=AppenderCall calls+=AppenderCall*)
	 */
	protected void sequence_LocalAppender(ISerializationContext context, LocalAppender semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Layout returns LocalLayout
	 *     LocalLayout returns LocalLayout
	 *
	 * Constraint:
	 *     (name=ID (parameters+=Parameter parameters+=Parameter*)? call=LayoutCall)
	 */
	protected void sequence_LocalLayout(ISerializationContext context, LocalLayout semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BoundType returns LowerBound
	 *     LowerBound returns LowerBound
	 *
	 * Constraint:
	 *     n=INT
	 */
	protected void sequence_LowerBound(ISerializationContext context, LowerBound semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MoniLog4DSLPackage.Literals.BOUND_TYPE__N) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MoniLog4DSLPackage.Literals.BOUND_TYPE__N));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLowerBoundAccess().getNINTTerminalRuleCall_1_0(), semanticObject.getN());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Action returns StartMoniLogger
	 *     MoniLoggerCall returns StartMoniLogger
	 *
	 * Constraint:
	 *     (monilogger=[MoniLogger|ID] (args+=Expression args+=Expression*)?)
	 */
	protected void sequence_MoniLoggerCall(ISerializationContext context, StartMoniLogger semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Action returns StopMoniLogger
	 *     MoniLoggerCall returns StopMoniLogger
	 *
	 * Constraint:
	 *     monilogger=[MoniLogger|ID]
	 */
	protected void sequence_MoniLoggerCall(ISerializationContext context, StopMoniLogger semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MoniLog4DSLPackage.Literals.MONI_LOGGER_CALL__MONILOGGER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MoniLog4DSLPackage.Literals.MONI_LOGGER_CALL__MONILOGGER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMoniLoggerCallAccess().getMoniloggerMoniLoggerIDTerminalRuleCall_1_1_0_1(), semanticObject.eGet(MoniLog4DSLPackage.Literals.MONI_LOGGER_CALL__MONILOGGER, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     MoniLogger returns MoniLogger
	 *
	 * Constraint:
	 *     (
	 *         annotations+=MoniLoggerAnnotation* 
	 *         name=ID 
	 *         (parameters+=Parameter parameters+=Parameter*)? 
	 *         level=LogLevel? 
	 *         event=[Event|ID] 
	 *         (conditions+=Condition conditions+=Condition*)? 
	 *         actions+=Action 
	 *         actions+=Action*
	 *     )
	 */
	protected void sequence_MoniLogger(ISerializationContext context, MoniLogger semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AppenderCallArgument returns ParameterReference
	 *     Expression returns ParameterReference
	 *     ParameterReference returns ParameterReference
	 *
	 * Constraint:
	 *     parameter=[Parameter|ID]
	 */
	protected void sequence_ParameterReference(ISerializationContext context, ParameterReference semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MoniLog4DSLPackage.Literals.PARAMETER_REFERENCE__PARAMETER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MoniLog4DSLPackage.Literals.PARAMETER_REFERENCE__PARAMETER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getParameterReferenceAccess().getParameterParameterIDTerminalRuleCall_0_1(), semanticObject.eGet(MoniLog4DSLPackage.Literals.PARAMETER_REFERENCE__PARAMETER, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Parameter returns Parameter
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_Parameter(ISerializationContext context, org.gemoc.monilog.moniLog4DSL.Parameter semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MoniLog4DSLPackage.Literals.PARAMETER__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MoniLog4DSLPackage.Literals.PARAMETER__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getParameterAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Pattern returns Absence
	 *
	 * Constraint:
	 *     event=StreamEvent
	 */
	protected void sequence_Pattern(ISerializationContext context, Absence semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MoniLog4DSLPackage.Literals.ABSENCE__EVENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MoniLog4DSLPackage.Literals.ABSENCE__EVENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPatternAccess().getEventStreamEventParserRuleCall_2_2_0(), semanticObject.getEvent());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Pattern returns Existence
	 *
	 * Constraint:
	 *     (bound=BoundType? event=StreamEvent)
	 */
	protected void sequence_Pattern(ISerializationContext context, Existence semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Pattern returns Precedence
	 *
	 * Constraint:
	 *     (predecessor=StreamEvent successor=StreamEvent)
	 */
	protected void sequence_Pattern(ISerializationContext context, Precedence semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MoniLog4DSLPackage.Literals.PRECEDENCE__PREDECESSOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MoniLog4DSLPackage.Literals.PRECEDENCE__PREDECESSOR));
			if (transientValues.isValueTransient(semanticObject, MoniLog4DSLPackage.Literals.PRECEDENCE__SUCCESSOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MoniLog4DSLPackage.Literals.PRECEDENCE__SUCCESSOR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPatternAccess().getPredecessorStreamEventParserRuleCall_3_1_0(), semanticObject.getPredecessor());
		feeder.accept(grammarAccess.getPatternAccess().getSuccessorStreamEventParserRuleCall_3_3_0(), semanticObject.getSuccessor());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Pattern returns Response
	 *
	 * Constraint:
	 *     (event=StreamEvent trigger=StreamEvent)
	 */
	protected void sequence_Pattern(ISerializationContext context, Response semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MoniLog4DSLPackage.Literals.RESPONSE__EVENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MoniLog4DSLPackage.Literals.RESPONSE__EVENT));
			if (transientValues.isValueTransient(semanticObject, MoniLog4DSLPackage.Literals.RESPONSE__TRIGGER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MoniLog4DSLPackage.Literals.RESPONSE__TRIGGER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPatternAccess().getEventStreamEventParserRuleCall_4_1_0(), semanticObject.getEvent());
		feeder.accept(grammarAccess.getPatternAccess().getTriggerStreamEventParserRuleCall_4_3_0(), semanticObject.getTrigger());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Pattern returns Universality
	 *
	 * Constraint:
	 *     event=StreamEvent
	 */
	protected void sequence_Pattern(ISerializationContext context, Universality semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MoniLog4DSLPackage.Literals.UNIVERSALITY__EVENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MoniLog4DSLPackage.Literals.UNIVERSALITY__EVENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPatternAccess().getEventStreamEventParserRuleCall_1_2_0(), semanticObject.getEvent());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Scope returns After
	 *
	 * Constraint:
	 *     lowerBound=StreamEvent
	 */
	protected void sequence_Scope(ISerializationContext context, After semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MoniLog4DSLPackage.Literals.AFTER__LOWER_BOUND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MoniLog4DSLPackage.Literals.AFTER__LOWER_BOUND));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getScopeAccess().getLowerBoundStreamEventParserRuleCall_1_2_0(), semanticObject.getLowerBound());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Scope returns AfterUntil
	 *
	 * Constraint:
	 *     (lowerBound=StreamEvent upperBound=StreamEvent)
	 */
	protected void sequence_Scope(ISerializationContext context, AfterUntil semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MoniLog4DSLPackage.Literals.AFTER_UNTIL__LOWER_BOUND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MoniLog4DSLPackage.Literals.AFTER_UNTIL__LOWER_BOUND));
			if (transientValues.isValueTransient(semanticObject, MoniLog4DSLPackage.Literals.AFTER_UNTIL__UPPER_BOUND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MoniLog4DSLPackage.Literals.AFTER_UNTIL__UPPER_BOUND));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getScopeAccess().getLowerBoundStreamEventParserRuleCall_4_2_0(), semanticObject.getLowerBound());
		feeder.accept(grammarAccess.getScopeAccess().getUpperBoundStreamEventParserRuleCall_4_4_0(), semanticObject.getUpperBound());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Scope returns Before
	 *
	 * Constraint:
	 *     upperBound=StreamEvent
	 */
	protected void sequence_Scope(ISerializationContext context, Before semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MoniLog4DSLPackage.Literals.BEFORE__UPPER_BOUND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MoniLog4DSLPackage.Literals.BEFORE__UPPER_BOUND));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getScopeAccess().getUpperBoundStreamEventParserRuleCall_2_2_0(), semanticObject.getUpperBound());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Scope returns Between
	 *
	 * Constraint:
	 *     (lowerBound=StreamEvent upperBound=StreamEvent)
	 */
	protected void sequence_Scope(ISerializationContext context, Between semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MoniLog4DSLPackage.Literals.BETWEEN__LOWER_BOUND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MoniLog4DSLPackage.Literals.BETWEEN__LOWER_BOUND));
			if (transientValues.isValueTransient(semanticObject, MoniLog4DSLPackage.Literals.BETWEEN__UPPER_BOUND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MoniLog4DSLPackage.Literals.BETWEEN__UPPER_BOUND));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getScopeAccess().getLowerBoundStreamEventParserRuleCall_3_2_0(), semanticObject.getLowerBound());
		feeder.accept(grammarAccess.getScopeAccess().getUpperBoundStreamEventParserRuleCall_3_4_0(), semanticObject.getUpperBound());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Scope returns Globally
	 *
	 * Constraint:
	 *     {Globally}
	 */
	protected void sequence_Scope(ISerializationContext context, Globally semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     StreamEvent returns StreamEvent
	 *
	 * Constraint:
	 *     (event=[Event|ID] (values+=EmptyOrPropertyValue values+=EmptyOrPropertyValue*)?)
	 */
	protected void sequence_StreamEvent(ISerializationContext context, StreamEvent semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TemporalPattern returns TemporalPattern
	 *
	 * Constraint:
	 *     (pattern=Pattern scope=Scope)
	 */
	protected void sequence_TemporalPattern(ISerializationContext context, TemporalPattern semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MoniLog4DSLPackage.Literals.TEMPORAL_PATTERN__PATTERN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MoniLog4DSLPackage.Literals.TEMPORAL_PATTERN__PATTERN));
			if (transientValues.isValueTransient(semanticObject, MoniLog4DSLPackage.Literals.TEMPORAL_PATTERN__SCOPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MoniLog4DSLPackage.Literals.TEMPORAL_PATTERN__SCOPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTemporalPatternAccess().getPatternPatternParserRuleCall_0_0(), semanticObject.getPattern());
		feeder.accept(grammarAccess.getTemporalPatternAccess().getScopeScopeParserRuleCall_1_0(), semanticObject.getScope());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     BoundType returns UpperBound
	 *     UpperBound returns UpperBound
	 *
	 * Constraint:
	 *     n=INT
	 */
	protected void sequence_UpperBound(ISerializationContext context, UpperBound semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MoniLog4DSLPackage.Literals.BOUND_TYPE__N) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MoniLog4DSLPackage.Literals.BOUND_TYPE__N));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUpperBoundAccess().getNINTTerminalRuleCall_1_0(), semanticObject.getN());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Event returns UserEvent
	 *     UserEvent returns UserEvent
	 *
	 * Constraint:
	 *     (name=ID (parameters+=Parameter parameters+=Parameter*)?)
	 */
	protected void sequence_UserEvent(ISerializationContext context, UserEvent semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
