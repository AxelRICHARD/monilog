/*
 * generated by Xtext 2.21.0
 */
package org.gemoc.monilog.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.gemoc.monilog.moniLog.ASTEvent;
import org.gemoc.monilog.moniLog.Absence;
import org.gemoc.monilog.moniLog.After;
import org.gemoc.monilog.moniLog.AfterASTEvent;
import org.gemoc.monilog.moniLog.AfterUntil;
import org.gemoc.monilog.moniLog.And;
import org.gemoc.monilog.moniLog.AppenderCall;
import org.gemoc.monilog.moniLog.ArrayRef;
import org.gemoc.monilog.moniLog.ArraySize;
import org.gemoc.monilog.moniLog.Before;
import org.gemoc.monilog.moniLog.BeforeASTEvent;
import org.gemoc.monilog.moniLog.Between;
import org.gemoc.monilog.moniLog.BoolConstant;
import org.gemoc.monilog.moniLog.Comparison;
import org.gemoc.monilog.moniLog.ComplexEvent;
import org.gemoc.monilog.moniLog.Condition;
import org.gemoc.monilog.moniLog.ContractedIf;
import org.gemoc.monilog.moniLog.Div;
import org.gemoc.monilog.moniLog.Document;
import org.gemoc.monilog.moniLog.EmitEvent;
import org.gemoc.monilog.moniLog.Empty;
import org.gemoc.monilog.moniLog.Equality;
import org.gemoc.monilog.moniLog.ExactBound;
import org.gemoc.monilog.moniLog.Existence;
import org.gemoc.monilog.moniLog.ExternalAppender;
import org.gemoc.monilog.moniLog.ExternalLayout;
import org.gemoc.monilog.moniLog.FileAlias;
import org.gemoc.monilog.moniLog.Globally;
import org.gemoc.monilog.moniLog.Import;
import org.gemoc.monilog.moniLog.IntConstant;
import org.gemoc.monilog.moniLog.LanguageCall;
import org.gemoc.monilog.moniLog.LanguageExpression;
import org.gemoc.monilog.moniLog.LanguageValue;
import org.gemoc.monilog.moniLog.LayoutCall;
import org.gemoc.monilog.moniLog.LocalAppender;
import org.gemoc.monilog.moniLog.LocalLayout;
import org.gemoc.monilog.moniLog.LowerBound;
import org.gemoc.monilog.moniLog.Minus;
import org.gemoc.monilog.moniLog.Modulo;
import org.gemoc.monilog.moniLog.MoniLogExpression;
import org.gemoc.monilog.moniLog.MoniLogPackage;
import org.gemoc.monilog.moniLog.MoniLogger;
import org.gemoc.monilog.moniLog.Mul;
import org.gemoc.monilog.moniLog.Not;
import org.gemoc.monilog.moniLog.Or;
import org.gemoc.monilog.moniLog.ParameterDecl;
import org.gemoc.monilog.moniLog.ParameterReference;
import org.gemoc.monilog.moniLog.Parenthesis;
import org.gemoc.monilog.moniLog.Plus;
import org.gemoc.monilog.moniLog.Precedence;
import org.gemoc.monilog.moniLog.PropertyRef;
import org.gemoc.monilog.moniLog.PropertyValue;
import org.gemoc.monilog.moniLog.RealConstant;
import org.gemoc.monilog.moniLog.Response;
import org.gemoc.monilog.moniLog.SimpleVarRef;
import org.gemoc.monilog.moniLog.StartMoniLogger;
import org.gemoc.monilog.moniLog.StopMoniLogger;
import org.gemoc.monilog.moniLog.StreamEvent;
import org.gemoc.monilog.moniLog.StringConstant;
import org.gemoc.monilog.moniLog.TemporalPattern;
import org.gemoc.monilog.moniLog.UnaryMinus;
import org.gemoc.monilog.moniLog.Universality;
import org.gemoc.monilog.moniLog.UpperBound;
import org.gemoc.monilog.moniLog.UserEvent;
import org.gemoc.monilog.moniLog.VectorConstant;
import org.gemoc.monilog.services.MoniLogGrammarAccess;

@SuppressWarnings("all")
public class MoniLogSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private MoniLogGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == MoniLogPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case MoniLogPackage.AST_EVENT:
				sequence_Event(context, (ASTEvent) semanticObject); 
				return; 
			case MoniLogPackage.ABSENCE:
				sequence_Pattern(context, (Absence) semanticObject); 
				return; 
			case MoniLogPackage.AFTER:
				sequence_Scope(context, (After) semanticObject); 
				return; 
			case MoniLogPackage.AFTER_AST_EVENT:
				sequence_ASTEventKind(context, (AfterASTEvent) semanticObject); 
				return; 
			case MoniLogPackage.AFTER_UNTIL:
				sequence_Scope(context, (AfterUntil) semanticObject); 
				return; 
			case MoniLogPackage.AND:
				sequence_And(context, (And) semanticObject); 
				return; 
			case MoniLogPackage.APPENDER_CALL:
				sequence_AppenderCall(context, (AppenderCall) semanticObject); 
				return; 
			case MoniLogPackage.ARRAY_REF:
				sequence_Ref(context, (ArrayRef) semanticObject); 
				return; 
			case MoniLogPackage.ARRAY_SIZE:
				sequence_ArraySize(context, (ArraySize) semanticObject); 
				return; 
			case MoniLogPackage.BEFORE:
				sequence_Scope(context, (Before) semanticObject); 
				return; 
			case MoniLogPackage.BEFORE_AST_EVENT:
				sequence_ASTEventKind(context, (BeforeASTEvent) semanticObject); 
				return; 
			case MoniLogPackage.BETWEEN:
				sequence_Scope(context, (Between) semanticObject); 
				return; 
			case MoniLogPackage.BOOL_CONSTANT:
				sequence_Atomic(context, (BoolConstant) semanticObject); 
				return; 
			case MoniLogPackage.COMPARISON:
				sequence_Comparison(context, (Comparison) semanticObject); 
				return; 
			case MoniLogPackage.COMPLEX_EVENT:
				sequence_Event(context, (ComplexEvent) semanticObject); 
				return; 
			case MoniLogPackage.CONDITION:
				sequence_Condition(context, (Condition) semanticObject); 
				return; 
			case MoniLogPackage.CONTRACTED_IF:
				sequence_ContractedIf(context, (ContractedIf) semanticObject); 
				return; 
			case MoniLogPackage.DIV:
				sequence_MulOrDiv(context, (Div) semanticObject); 
				return; 
			case MoniLogPackage.DOCUMENT:
				sequence_Document(context, (Document) semanticObject); 
				return; 
			case MoniLogPackage.EMIT_EVENT:
				sequence_EmitEvent(context, (EmitEvent) semanticObject); 
				return; 
			case MoniLogPackage.EMPTY:
				sequence_EmptyOrPropertyValue(context, (Empty) semanticObject); 
				return; 
			case MoniLogPackage.EQUALITY:
				sequence_Equality(context, (Equality) semanticObject); 
				return; 
			case MoniLogPackage.EXACT_BOUND:
				sequence_ExactBound(context, (ExactBound) semanticObject); 
				return; 
			case MoniLogPackage.EXISTENCE:
				sequence_Pattern(context, (Existence) semanticObject); 
				return; 
			case MoniLogPackage.EXTERNAL_APPENDER:
				sequence_ExternalAppender(context, (ExternalAppender) semanticObject); 
				return; 
			case MoniLogPackage.EXTERNAL_LAYOUT:
				sequence_ExternalLayout(context, (ExternalLayout) semanticObject); 
				return; 
			case MoniLogPackage.FILE_ALIAS:
				sequence_FileAlias(context, (FileAlias) semanticObject); 
				return; 
			case MoniLogPackage.GLOBALLY:
				sequence_Scope(context, (Globally) semanticObject); 
				return; 
			case MoniLogPackage.IMPORT:
				sequence_Import(context, (Import) semanticObject); 
				return; 
			case MoniLogPackage.INT_CONSTANT:
				sequence_Atomic(context, (IntConstant) semanticObject); 
				return; 
			case MoniLogPackage.LANGUAGE_CALL:
				sequence_LanguageCall(context, (LanguageCall) semanticObject); 
				return; 
			case MoniLogPackage.LANGUAGE_EXPRESSION:
				sequence_LanguageExpression(context, (LanguageExpression) semanticObject); 
				return; 
			case MoniLogPackage.LANGUAGE_VALUE:
				sequence_LanguageValue(context, (LanguageValue) semanticObject); 
				return; 
			case MoniLogPackage.LAYOUT_CALL:
				sequence_LayoutCall(context, (LayoutCall) semanticObject); 
				return; 
			case MoniLogPackage.LOCAL_APPENDER:
				sequence_LocalAppender(context, (LocalAppender) semanticObject); 
				return; 
			case MoniLogPackage.LOCAL_LAYOUT:
				sequence_LocalLayout(context, (LocalLayout) semanticObject); 
				return; 
			case MoniLogPackage.LOWER_BOUND:
				sequence_LowerBound(context, (LowerBound) semanticObject); 
				return; 
			case MoniLogPackage.MINUS:
				sequence_PlusOrMinus(context, (Minus) semanticObject); 
				return; 
			case MoniLogPackage.MODULO:
				sequence_Modulo(context, (Modulo) semanticObject); 
				return; 
			case MoniLogPackage.MONI_LOG_EXPRESSION:
				sequence_MoniLogExpression(context, (MoniLogExpression) semanticObject); 
				return; 
			case MoniLogPackage.MONI_LOGGER:
				sequence_MoniLogger(context, (MoniLogger) semanticObject); 
				return; 
			case MoniLogPackage.MUL:
				sequence_MulOrDiv(context, (Mul) semanticObject); 
				return; 
			case MoniLogPackage.NOT:
				sequence_Primary(context, (Not) semanticObject); 
				return; 
			case MoniLogPackage.OR:
				sequence_Or(context, (Or) semanticObject); 
				return; 
			case MoniLogPackage.PARAMETER:
				sequence_Parameter(context, (org.gemoc.monilog.moniLog.Parameter) semanticObject); 
				return; 
			case MoniLogPackage.PARAMETER_DECL:
				if (rule == grammarAccess.getParameterDeclNoVarArgsRule()) {
					sequence_ParameterDeclNoVarArgs(context, (ParameterDecl) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getParameterDeclVarArgsRule()) {
					sequence_ParameterDeclVarArgs(context, (ParameterDecl) semanticObject); 
					return; 
				}
				else break;
			case MoniLogPackage.PARAMETER_REFERENCE:
				sequence_ParameterReference(context, (ParameterReference) semanticObject); 
				return; 
			case MoniLogPackage.PARENTHESIS:
				sequence_Primary(context, (Parenthesis) semanticObject); 
				return; 
			case MoniLogPackage.PLUS:
				sequence_PlusOrMinus(context, (Plus) semanticObject); 
				return; 
			case MoniLogPackage.PRECEDENCE:
				sequence_Pattern(context, (Precedence) semanticObject); 
				return; 
			case MoniLogPackage.PROPERTY_REF:
				sequence_Ref(context, (PropertyRef) semanticObject); 
				return; 
			case MoniLogPackage.PROPERTY_VALUE:
				sequence_PropertyValue(context, (PropertyValue) semanticObject); 
				return; 
			case MoniLogPackage.REAL_CONSTANT:
				sequence_Atomic(context, (RealConstant) semanticObject); 
				return; 
			case MoniLogPackage.RESPONSE:
				sequence_Pattern(context, (Response) semanticObject); 
				return; 
			case MoniLogPackage.SIMPLE_VAR_REF:
				sequence_SimpleVarRef(context, (SimpleVarRef) semanticObject); 
				return; 
			case MoniLogPackage.START_MONI_LOGGER:
				sequence_MoniloggerCall(context, (StartMoniLogger) semanticObject); 
				return; 
			case MoniLogPackage.STOP_MONI_LOGGER:
				sequence_MoniloggerCall(context, (StopMoniLogger) semanticObject); 
				return; 
			case MoniLogPackage.STREAM_EVENT:
				sequence_StreamEvent(context, (StreamEvent) semanticObject); 
				return; 
			case MoniLogPackage.STRING_CONSTANT:
				sequence_Atomic(context, (StringConstant) semanticObject); 
				return; 
			case MoniLogPackage.TEMPORAL_PATTERN:
				sequence_TemporalPattern(context, (TemporalPattern) semanticObject); 
				return; 
			case MoniLogPackage.UNARY_MINUS:
				sequence_Primary(context, (UnaryMinus) semanticObject); 
				return; 
			case MoniLogPackage.UNIVERSALITY:
				sequence_Pattern(context, (Universality) semanticObject); 
				return; 
			case MoniLogPackage.UPPER_BOUND:
				sequence_UpperBound(context, (UpperBound) semanticObject); 
				return; 
			case MoniLogPackage.USER_EVENT:
				sequence_Event(context, (UserEvent) semanticObject); 
				return; 
			case MoniLogPackage.VECTOR_CONSTANT:
				sequence_Atomic(context, (VectorConstant) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     ASTEventKind returns AfterASTEvent
	 *
	 * Constraint:
	 *     {AfterASTEvent}
	 */
	protected void sequence_ASTEventKind(ISerializationContext context, AfterASTEvent semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ASTEventKind returns BeforeASTEvent
	 *
	 * Constraint:
	 *     {BeforeASTEvent}
	 */
	protected void sequence_ASTEventKind(ISerializationContext context, BeforeASTEvent semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SimpleExpression returns And
	 *     ContractedIf returns And
	 *     ContractedIf.ContractedIf_1_0 returns And
	 *     Or returns And
	 *     Or.Or_1_0 returns And
	 *     And returns And
	 *     And.And_1_0 returns And
	 *
	 * Constraint:
	 *     (left=And_And_1_0 op='&&' right=Equality)
	 */
	protected void sequence_And(ISerializationContext context, And semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MoniLogPackage.Literals.AND__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MoniLogPackage.Literals.AND__LEFT));
			if (transientValues.isValueTransient(semanticObject, MoniLogPackage.Literals.AND__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MoniLogPackage.Literals.AND__OP));
			if (transientValues.isValueTransient(semanticObject, MoniLogPackage.Literals.AND__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MoniLogPackage.Literals.AND__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAndAccess().getAndLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getAndAccess().getOpAmpersandAmpersandKeyword_1_1_0(), semanticObject.getOp());
		feeder.accept(grammarAccess.getAndAccess().getRightEqualityParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Action returns AppenderCall
	 *     AppenderCall returns AppenderCall
	 *
	 * Constraint:
	 *     (appender=[Appender|QualifiedName] (args+=Expression args+=Expression*)?)
	 */
	protected void sequence_AppenderCall(ISerializationContext context, AppenderCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SimpleExpression returns ArraySize
	 *     ContractedIf returns ArraySize
	 *     ContractedIf.ContractedIf_1_0 returns ArraySize
	 *     Or returns ArraySize
	 *     Or.Or_1_0 returns ArraySize
	 *     And returns ArraySize
	 *     And.And_1_0 returns ArraySize
	 *     Equality returns ArraySize
	 *     Equality.Equality_1_0 returns ArraySize
	 *     Comparison returns ArraySize
	 *     Comparison.Comparison_1_0 returns ArraySize
	 *     PlusOrMinus returns ArraySize
	 *     PlusOrMinus.Plus_1_0_0_0 returns ArraySize
	 *     PlusOrMinus.Minus_1_0_1_0 returns ArraySize
	 *     MulOrDiv returns ArraySize
	 *     MulOrDiv.Mul_1_0_0_0 returns ArraySize
	 *     MulOrDiv.Div_1_0_1_0 returns ArraySize
	 *     Modulo returns ArraySize
	 *     Modulo.Modulo_1_0 returns ArraySize
	 *     Primary returns ArraySize
	 *     Atomic returns ArraySize
	 *     ArraySize returns ArraySize
	 *
	 * Constraint:
	 *     array=Ref
	 */
	protected void sequence_ArraySize(ISerializationContext context, ArraySize semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MoniLogPackage.Literals.ARRAY_SIZE__ARRAY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MoniLogPackage.Literals.ARRAY_SIZE__ARRAY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getArraySizeAccess().getArrayRefParserRuleCall_2_0(), semanticObject.getArray());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SimpleExpression returns BoolConstant
	 *     ContractedIf returns BoolConstant
	 *     ContractedIf.ContractedIf_1_0 returns BoolConstant
	 *     Or returns BoolConstant
	 *     Or.Or_1_0 returns BoolConstant
	 *     And returns BoolConstant
	 *     And.And_1_0 returns BoolConstant
	 *     Equality returns BoolConstant
	 *     Equality.Equality_1_0 returns BoolConstant
	 *     Comparison returns BoolConstant
	 *     Comparison.Comparison_1_0 returns BoolConstant
	 *     PlusOrMinus returns BoolConstant
	 *     PlusOrMinus.Plus_1_0_0_0 returns BoolConstant
	 *     PlusOrMinus.Minus_1_0_1_0 returns BoolConstant
	 *     MulOrDiv returns BoolConstant
	 *     MulOrDiv.Mul_1_0_0_0 returns BoolConstant
	 *     MulOrDiv.Div_1_0_1_0 returns BoolConstant
	 *     Modulo returns BoolConstant
	 *     Modulo.Modulo_1_0 returns BoolConstant
	 *     Primary returns BoolConstant
	 *     Atomic returns BoolConstant
	 *
	 * Constraint:
	 *     value?='true'?
	 */
	protected void sequence_Atomic(ISerializationContext context, BoolConstant semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SimpleExpression returns IntConstant
	 *     ContractedIf returns IntConstant
	 *     ContractedIf.ContractedIf_1_0 returns IntConstant
	 *     Or returns IntConstant
	 *     Or.Or_1_0 returns IntConstant
	 *     And returns IntConstant
	 *     And.And_1_0 returns IntConstant
	 *     Equality returns IntConstant
	 *     Equality.Equality_1_0 returns IntConstant
	 *     Comparison returns IntConstant
	 *     Comparison.Comparison_1_0 returns IntConstant
	 *     PlusOrMinus returns IntConstant
	 *     PlusOrMinus.Plus_1_0_0_0 returns IntConstant
	 *     PlusOrMinus.Minus_1_0_1_0 returns IntConstant
	 *     MulOrDiv returns IntConstant
	 *     MulOrDiv.Mul_1_0_0_0 returns IntConstant
	 *     MulOrDiv.Div_1_0_1_0 returns IntConstant
	 *     Modulo returns IntConstant
	 *     Modulo.Modulo_1_0 returns IntConstant
	 *     Primary returns IntConstant
	 *     Atomic returns IntConstant
	 *
	 * Constraint:
	 *     value=INT
	 */
	protected void sequence_Atomic(ISerializationContext context, IntConstant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MoniLogPackage.Literals.INT_CONSTANT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MoniLogPackage.Literals.INT_CONSTANT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicAccess().getValueINTTerminalRuleCall_0_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SimpleExpression returns RealConstant
	 *     ContractedIf returns RealConstant
	 *     ContractedIf.ContractedIf_1_0 returns RealConstant
	 *     Or returns RealConstant
	 *     Or.Or_1_0 returns RealConstant
	 *     And returns RealConstant
	 *     And.And_1_0 returns RealConstant
	 *     Equality returns RealConstant
	 *     Equality.Equality_1_0 returns RealConstant
	 *     Comparison returns RealConstant
	 *     Comparison.Comparison_1_0 returns RealConstant
	 *     PlusOrMinus returns RealConstant
	 *     PlusOrMinus.Plus_1_0_0_0 returns RealConstant
	 *     PlusOrMinus.Minus_1_0_1_0 returns RealConstant
	 *     MulOrDiv returns RealConstant
	 *     MulOrDiv.Mul_1_0_0_0 returns RealConstant
	 *     MulOrDiv.Div_1_0_1_0 returns RealConstant
	 *     Modulo returns RealConstant
	 *     Modulo.Modulo_1_0 returns RealConstant
	 *     Primary returns RealConstant
	 *     Atomic returns RealConstant
	 *
	 * Constraint:
	 *     value=REAL
	 */
	protected void sequence_Atomic(ISerializationContext context, RealConstant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MoniLogPackage.Literals.REAL_CONSTANT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MoniLogPackage.Literals.REAL_CONSTANT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicAccess().getValueREALTerminalRuleCall_1_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SimpleExpression returns StringConstant
	 *     ContractedIf returns StringConstant
	 *     ContractedIf.ContractedIf_1_0 returns StringConstant
	 *     Or returns StringConstant
	 *     Or.Or_1_0 returns StringConstant
	 *     And returns StringConstant
	 *     And.And_1_0 returns StringConstant
	 *     Equality returns StringConstant
	 *     Equality.Equality_1_0 returns StringConstant
	 *     Comparison returns StringConstant
	 *     Comparison.Comparison_1_0 returns StringConstant
	 *     PlusOrMinus returns StringConstant
	 *     PlusOrMinus.Plus_1_0_0_0 returns StringConstant
	 *     PlusOrMinus.Minus_1_0_1_0 returns StringConstant
	 *     MulOrDiv returns StringConstant
	 *     MulOrDiv.Mul_1_0_0_0 returns StringConstant
	 *     MulOrDiv.Div_1_0_1_0 returns StringConstant
	 *     Modulo returns StringConstant
	 *     Modulo.Modulo_1_0 returns StringConstant
	 *     Primary returns StringConstant
	 *     Atomic returns StringConstant
	 *
	 * Constraint:
	 *     value=STRING
	 */
	protected void sequence_Atomic(ISerializationContext context, StringConstant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MoniLogPackage.Literals.STRING_CONSTANT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MoniLogPackage.Literals.STRING_CONSTANT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicAccess().getValueSTRINGTerminalRuleCall_3_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SimpleExpression returns VectorConstant
	 *     ContractedIf returns VectorConstant
	 *     ContractedIf.ContractedIf_1_0 returns VectorConstant
	 *     Or returns VectorConstant
	 *     Or.Or_1_0 returns VectorConstant
	 *     And returns VectorConstant
	 *     And.And_1_0 returns VectorConstant
	 *     Equality returns VectorConstant
	 *     Equality.Equality_1_0 returns VectorConstant
	 *     Comparison returns VectorConstant
	 *     Comparison.Comparison_1_0 returns VectorConstant
	 *     PlusOrMinus returns VectorConstant
	 *     PlusOrMinus.Plus_1_0_0_0 returns VectorConstant
	 *     PlusOrMinus.Minus_1_0_1_0 returns VectorConstant
	 *     MulOrDiv returns VectorConstant
	 *     MulOrDiv.Mul_1_0_0_0 returns VectorConstant
	 *     MulOrDiv.Div_1_0_1_0 returns VectorConstant
	 *     Modulo returns VectorConstant
	 *     Modulo.Modulo_1_0 returns VectorConstant
	 *     Primary returns VectorConstant
	 *     Atomic returns VectorConstant
	 *
	 * Constraint:
	 *     (values+=SimpleExpression values+=SimpleExpression*)
	 */
	protected void sequence_Atomic(ISerializationContext context, VectorConstant semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SimpleExpression returns Comparison
	 *     ContractedIf returns Comparison
	 *     ContractedIf.ContractedIf_1_0 returns Comparison
	 *     Or returns Comparison
	 *     Or.Or_1_0 returns Comparison
	 *     And returns Comparison
	 *     And.And_1_0 returns Comparison
	 *     Equality returns Comparison
	 *     Equality.Equality_1_0 returns Comparison
	 *     Comparison returns Comparison
	 *     Comparison.Comparison_1_0 returns Comparison
	 *
	 * Constraint:
	 *     (left=Comparison_Comparison_1_0 (op='>=' | op='<=' | op='>' | op='<') right=PlusOrMinus)
	 */
	protected void sequence_Comparison(ISerializationContext context, Comparison semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Condition returns Condition
	 *
	 * Constraint:
	 *     expression=LanguageValue
	 */
	protected void sequence_Condition(ISerializationContext context, Condition semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MoniLogPackage.Literals.CONDITION__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MoniLogPackage.Literals.CONDITION__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConditionAccess().getExpressionLanguageValueParserRuleCall_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SimpleExpression returns ContractedIf
	 *     ContractedIf returns ContractedIf
	 *     ContractedIf.ContractedIf_1_0 returns ContractedIf
	 *
	 * Constraint:
	 *     (condition=ContractedIf_ContractedIf_1_0 then=Or else=Or)
	 */
	protected void sequence_ContractedIf(ISerializationContext context, ContractedIf semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MoniLogPackage.Literals.CONTRACTED_IF__CONDITION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MoniLogPackage.Literals.CONTRACTED_IF__CONDITION));
			if (transientValues.isValueTransient(semanticObject, MoniLogPackage.Literals.CONTRACTED_IF__THEN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MoniLogPackage.Literals.CONTRACTED_IF__THEN));
			if (transientValues.isValueTransient(semanticObject, MoniLogPackage.Literals.CONTRACTED_IF__ELSE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MoniLogPackage.Literals.CONTRACTED_IF__ELSE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getContractedIfAccess().getContractedIfConditionAction_1_0(), semanticObject.getCondition());
		feeder.accept(grammarAccess.getContractedIfAccess().getThenOrParserRuleCall_1_2_0(), semanticObject.getThen());
		feeder.accept(grammarAccess.getContractedIfAccess().getElseOrParserRuleCall_1_4_0(), semanticObject.getElse());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Document returns Document
	 *
	 * Constraint:
	 *     (name=QualifiedName imports+=Import* (events+=Event | appenders+=Appender | layouts+=Layout | moniloggers+=MoniLogger)*)
	 */
	protected void sequence_Document(ISerializationContext context, Document semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Action returns EmitEvent
	 *     EmitEvent returns EmitEvent
	 *
	 * Constraint:
	 *     (event=[UserEvent|ID] (args+=Expression args+=Expression*)?)
	 */
	protected void sequence_EmitEvent(ISerializationContext context, EmitEvent semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EmptyOrPropertyValue returns Empty
	 *
	 * Constraint:
	 *     {Empty}
	 */
	protected void sequence_EmptyOrPropertyValue(ISerializationContext context, Empty semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SimpleExpression returns Equality
	 *     ContractedIf returns Equality
	 *     ContractedIf.ContractedIf_1_0 returns Equality
	 *     Or returns Equality
	 *     Or.Or_1_0 returns Equality
	 *     And returns Equality
	 *     And.And_1_0 returns Equality
	 *     Equality returns Equality
	 *     Equality.Equality_1_0 returns Equality
	 *
	 * Constraint:
	 *     (left=Equality_Equality_1_0 (op='==' | op='!=') right=Comparison)
	 */
	protected void sequence_Equality(ISerializationContext context, Equality semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Event returns ASTEvent
	 *
	 * Constraint:
	 *     (name=ID parameterDecl=ParameterDeclNoVarArgs? kind=ASTEventKind ruleID=ID)
	 */
	protected void sequence_Event(ISerializationContext context, ASTEvent semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Event returns ComplexEvent
	 *
	 * Constraint:
	 *     (name=ID kind=TemporalPatternKind? parameterDecl=ParameterDeclNoVarArgs? pattern=TemporalPattern)
	 */
	protected void sequence_Event(ISerializationContext context, ComplexEvent semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Event returns UserEvent
	 *
	 * Constraint:
	 *     (name=ID parameterDecl=ParameterDeclNoVarArgs?)
	 */
	protected void sequence_Event(ISerializationContext context, UserEvent semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BoundType returns ExactBound
	 *     ExactBound returns ExactBound
	 *
	 * Constraint:
	 *     n=INT
	 */
	protected void sequence_ExactBound(ISerializationContext context, ExactBound semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MoniLogPackage.Literals.BOUND_TYPE__N) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MoniLogPackage.Literals.BOUND_TYPE__N));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExactBoundAccess().getNINTTerminalRuleCall_0(), semanticObject.getN());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Appender returns ExternalAppender
	 *     ExternalAppender returns ExternalAppender
	 *
	 * Constraint:
	 *     (name=ID parameterDecl=ParameterDeclVarArgs?)
	 */
	protected void sequence_ExternalAppender(ISerializationContext context, ExternalAppender semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Layout returns ExternalLayout
	 *     ExternalLayout returns ExternalLayout
	 *
	 * Constraint:
	 *     (name=ID parameterDecl=ParameterDeclVarArgs?)
	 */
	protected void sequence_ExternalLayout(ISerializationContext context, ExternalLayout semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FileAlias returns FileAlias
	 *
	 * Constraint:
	 *     (filePath=STRING name=ID)
	 */
	protected void sequence_FileAlias(ISerializationContext context, FileAlias semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MoniLogPackage.Literals.FILE_ALIAS__FILE_PATH) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MoniLogPackage.Literals.FILE_ALIAS__FILE_PATH));
			if (transientValues.isValueTransient(semanticObject, MoniLogPackage.Literals.FILE_ALIAS__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MoniLogPackage.Literals.FILE_ALIAS__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFileAliasAccess().getFilePathSTRINGTerminalRuleCall_0_0(), semanticObject.getFilePath());
		feeder.accept(grammarAccess.getFileAliasAccess().getNameIDTerminalRuleCall_2_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Import returns Import
	 *
	 * Constraint:
	 *     (importedNamespace=QualifiedNameWithWildcard | alias=FileAlias)
	 */
	protected void sequence_Import(ISerializationContext context, Import semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LanguageCall returns LanguageCall
	 *
	 * Constraint:
	 *     (file=[FileAlias|ID] fqn=QualifiedName (args+=Expression args+=Expression*)?)
	 */
	protected void sequence_LanguageCall(ISerializationContext context, LanguageCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LanguageExpression returns LanguageExpression
	 *
	 * Constraint:
	 *     expression=STRING
	 */
	protected void sequence_LanguageExpression(ISerializationContext context, LanguageExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MoniLogPackage.Literals.LANGUAGE_EXPRESSION__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MoniLogPackage.Literals.LANGUAGE_EXPRESSION__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLanguageExpressionAccess().getExpressionSTRINGTerminalRuleCall_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Action returns LanguageValue
	 *     Expression returns LanguageValue
	 *     LanguageValue returns LanguageValue
	 *
	 * Constraint:
	 *     (languageId=ID (value=LanguageExpression | value=LanguageCall))
	 */
	protected void sequence_LanguageValue(ISerializationContext context, LanguageValue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LayoutCall returns LayoutCall
	 *     Expression returns LayoutCall
	 *
	 * Constraint:
	 *     (layout=[Layout|QualifiedName] (args+=Expression args+=Expression*)?)
	 */
	protected void sequence_LayoutCall(ISerializationContext context, LayoutCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Appender returns LocalAppender
	 *     LocalAppender returns LocalAppender
	 *
	 * Constraint:
	 *     (annotations+=AppenderAnnotation* name=ID parameterDecl=ParameterDeclVarArgs? calls+=AppenderCall calls+=AppenderCall*)
	 */
	protected void sequence_LocalAppender(ISerializationContext context, LocalAppender semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Layout returns LocalLayout
	 *     LocalLayout returns LocalLayout
	 *
	 * Constraint:
	 *     (name=ID parameterDecl=ParameterDeclVarArgs? call=LayoutCall)
	 */
	protected void sequence_LocalLayout(ISerializationContext context, LocalLayout semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BoundType returns LowerBound
	 *     LowerBound returns LowerBound
	 *
	 * Constraint:
	 *     n=INT
	 */
	protected void sequence_LowerBound(ISerializationContext context, LowerBound semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MoniLogPackage.Literals.BOUND_TYPE__N) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MoniLogPackage.Literals.BOUND_TYPE__N));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLowerBoundAccess().getNINTTerminalRuleCall_1_0(), semanticObject.getN());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SimpleExpression returns Modulo
	 *     ContractedIf returns Modulo
	 *     ContractedIf.ContractedIf_1_0 returns Modulo
	 *     Or returns Modulo
	 *     Or.Or_1_0 returns Modulo
	 *     And returns Modulo
	 *     And.And_1_0 returns Modulo
	 *     Equality returns Modulo
	 *     Equality.Equality_1_0 returns Modulo
	 *     Comparison returns Modulo
	 *     Comparison.Comparison_1_0 returns Modulo
	 *     PlusOrMinus returns Modulo
	 *     PlusOrMinus.Plus_1_0_0_0 returns Modulo
	 *     PlusOrMinus.Minus_1_0_1_0 returns Modulo
	 *     MulOrDiv returns Modulo
	 *     MulOrDiv.Mul_1_0_0_0 returns Modulo
	 *     MulOrDiv.Div_1_0_1_0 returns Modulo
	 *     Modulo returns Modulo
	 *     Modulo.Modulo_1_0 returns Modulo
	 *
	 * Constraint:
	 *     (left=Modulo_Modulo_1_0 op='%' right=Primary)
	 */
	protected void sequence_Modulo(ISerializationContext context, Modulo semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MoniLogPackage.Literals.MODULO__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MoniLogPackage.Literals.MODULO__LEFT));
			if (transientValues.isValueTransient(semanticObject, MoniLogPackage.Literals.MODULO__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MoniLogPackage.Literals.MODULO__OP));
			if (transientValues.isValueTransient(semanticObject, MoniLogPackage.Literals.MODULO__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MoniLogPackage.Literals.MODULO__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getModuloAccess().getModuloLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getModuloAccess().getOpPercentSignKeyword_1_1_0(), semanticObject.getOp());
		feeder.accept(grammarAccess.getModuloAccess().getRightPrimaryParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns MoniLogExpression
	 *     MoniLogExpression returns MoniLogExpression
	 *
	 * Constraint:
	 *     expression=SimpleExpression
	 */
	protected void sequence_MoniLogExpression(ISerializationContext context, MoniLogExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MoniLogPackage.Literals.MONI_LOG_EXPRESSION__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MoniLogPackage.Literals.MONI_LOG_EXPRESSION__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMoniLogExpressionAccess().getExpressionSimpleExpressionParserRuleCall_1_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     MoniLogger returns MoniLogger
	 *
	 * Constraint:
	 *     (
	 *         annotations+=MoniLoggerAnnotation* 
	 *         name=ID 
	 *         parameterDecl=ParameterDeclVarArgs? 
	 *         level=LogLevel? 
	 *         streamEvent=StreamEvent 
	 *         (conditions+=Condition conditions+=Condition*)? 
	 *         actions+=Action 
	 *         actions+=Action*
	 *     )
	 */
	protected void sequence_MoniLogger(ISerializationContext context, MoniLogger semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Action returns StartMoniLogger
	 *     MoniloggerCall returns StartMoniLogger
	 *
	 * Constraint:
	 *     (monilogger=[MoniLogger|ID] (args+=Expression args+=Expression*)?)
	 */
	protected void sequence_MoniloggerCall(ISerializationContext context, StartMoniLogger semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Action returns StopMoniLogger
	 *     MoniloggerCall returns StopMoniLogger
	 *
	 * Constraint:
	 *     monilogger=[MoniLogger|ID]
	 */
	protected void sequence_MoniloggerCall(ISerializationContext context, StopMoniLogger semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MoniLogPackage.Literals.MONILOGGER_CALL__MONILOGGER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MoniLogPackage.Literals.MONILOGGER_CALL__MONILOGGER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMoniloggerCallAccess().getMoniloggerMoniLoggerIDTerminalRuleCall_1_1_0_1(), semanticObject.eGet(MoniLogPackage.Literals.MONILOGGER_CALL__MONILOGGER, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SimpleExpression returns Div
	 *     ContractedIf returns Div
	 *     ContractedIf.ContractedIf_1_0 returns Div
	 *     Or returns Div
	 *     Or.Or_1_0 returns Div
	 *     And returns Div
	 *     And.And_1_0 returns Div
	 *     Equality returns Div
	 *     Equality.Equality_1_0 returns Div
	 *     Comparison returns Div
	 *     Comparison.Comparison_1_0 returns Div
	 *     PlusOrMinus returns Div
	 *     PlusOrMinus.Plus_1_0_0_0 returns Div
	 *     PlusOrMinus.Minus_1_0_1_0 returns Div
	 *     MulOrDiv returns Div
	 *     MulOrDiv.Mul_1_0_0_0 returns Div
	 *     MulOrDiv.Div_1_0_1_0 returns Div
	 *
	 * Constraint:
	 *     (Left=MulOrDiv_Div_1_0_1_0 op='/' right=Modulo)
	 */
	protected void sequence_MulOrDiv(ISerializationContext context, Div semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MoniLogPackage.Literals.DIV__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MoniLogPackage.Literals.DIV__LEFT));
			if (transientValues.isValueTransient(semanticObject, MoniLogPackage.Literals.DIV__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MoniLogPackage.Literals.DIV__OP));
			if (transientValues.isValueTransient(semanticObject, MoniLogPackage.Literals.DIV__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MoniLogPackage.Literals.DIV__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMulOrDivAccess().getDivLeftAction_1_0_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getMulOrDivAccess().getOpSolidusKeyword_1_0_1_1_0(), semanticObject.getOp());
		feeder.accept(grammarAccess.getMulOrDivAccess().getRightModuloParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SimpleExpression returns Mul
	 *     ContractedIf returns Mul
	 *     ContractedIf.ContractedIf_1_0 returns Mul
	 *     Or returns Mul
	 *     Or.Or_1_0 returns Mul
	 *     And returns Mul
	 *     And.And_1_0 returns Mul
	 *     Equality returns Mul
	 *     Equality.Equality_1_0 returns Mul
	 *     Comparison returns Mul
	 *     Comparison.Comparison_1_0 returns Mul
	 *     PlusOrMinus returns Mul
	 *     PlusOrMinus.Plus_1_0_0_0 returns Mul
	 *     PlusOrMinus.Minus_1_0_1_0 returns Mul
	 *     MulOrDiv returns Mul
	 *     MulOrDiv.Mul_1_0_0_0 returns Mul
	 *     MulOrDiv.Div_1_0_1_0 returns Mul
	 *
	 * Constraint:
	 *     (left=MulOrDiv_Mul_1_0_0_0 op='*' right=Modulo)
	 */
	protected void sequence_MulOrDiv(ISerializationContext context, Mul semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MoniLogPackage.Literals.MUL__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MoniLogPackage.Literals.MUL__LEFT));
			if (transientValues.isValueTransient(semanticObject, MoniLogPackage.Literals.MUL__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MoniLogPackage.Literals.MUL__OP));
			if (transientValues.isValueTransient(semanticObject, MoniLogPackage.Literals.MUL__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MoniLogPackage.Literals.MUL__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMulOrDivAccess().getMulLeftAction_1_0_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getMulOrDivAccess().getOpAsteriskKeyword_1_0_0_1_0(), semanticObject.getOp());
		feeder.accept(grammarAccess.getMulOrDivAccess().getRightModuloParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SimpleExpression returns Or
	 *     ContractedIf returns Or
	 *     ContractedIf.ContractedIf_1_0 returns Or
	 *     Or returns Or
	 *     Or.Or_1_0 returns Or
	 *
	 * Constraint:
	 *     (left=Or_Or_1_0 op='||' right=And)
	 */
	protected void sequence_Or(ISerializationContext context, Or semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MoniLogPackage.Literals.OR__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MoniLogPackage.Literals.OR__LEFT));
			if (transientValues.isValueTransient(semanticObject, MoniLogPackage.Literals.OR__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MoniLogPackage.Literals.OR__OP));
			if (transientValues.isValueTransient(semanticObject, MoniLogPackage.Literals.OR__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MoniLogPackage.Literals.OR__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOrAccess().getOrLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getOrAccess().getOpVerticalLineVerticalLineKeyword_1_1_0(), semanticObject.getOp());
		feeder.accept(grammarAccess.getOrAccess().getRightAndParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ParameterDeclNoVarArgs returns ParameterDecl
	 *
	 * Constraint:
	 *     (parameters+=Parameter parameters+=Parameter*)?
	 */
	protected void sequence_ParameterDeclNoVarArgs(ISerializationContext context, ParameterDecl semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ParameterDeclVarArgs returns ParameterDecl
	 *
	 * Constraint:
	 *     (parameters+=Parameter parameters+=Parameter* varArgs=Parameter?)?
	 */
	protected void sequence_ParameterDeclVarArgs(ISerializationContext context, ParameterDecl semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns ParameterReference
	 *     ParameterReference returns ParameterReference
	 *
	 * Constraint:
	 *     parameter=[Parameter|ID]
	 */
	protected void sequence_ParameterReference(ISerializationContext context, ParameterReference semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MoniLogPackage.Literals.PARAMETER_REFERENCE__PARAMETER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MoniLogPackage.Literals.PARAMETER_REFERENCE__PARAMETER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getParameterReferenceAccess().getParameterParameterIDTerminalRuleCall_0_1(), semanticObject.eGet(MoniLogPackage.Literals.PARAMETER_REFERENCE__PARAMETER, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Parameter returns Parameter
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_Parameter(ISerializationContext context, org.gemoc.monilog.moniLog.Parameter semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MoniLogPackage.Literals.PARAMETER__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MoniLogPackage.Literals.PARAMETER__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getParameterAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Pattern returns Absence
	 *
	 * Constraint:
	 *     event=StreamEvent
	 */
	protected void sequence_Pattern(ISerializationContext context, Absence semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MoniLogPackage.Literals.ABSENCE__EVENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MoniLogPackage.Literals.ABSENCE__EVENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPatternAccess().getEventStreamEventParserRuleCall_2_2_0(), semanticObject.getEvent());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Pattern returns Existence
	 *
	 * Constraint:
	 *     (bound=BoundType? event=StreamEvent)
	 */
	protected void sequence_Pattern(ISerializationContext context, Existence semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Pattern returns Precedence
	 *
	 * Constraint:
	 *     (predecessor=StreamEvent successor=StreamEvent)
	 */
	protected void sequence_Pattern(ISerializationContext context, Precedence semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MoniLogPackage.Literals.PRECEDENCE__PREDECESSOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MoniLogPackage.Literals.PRECEDENCE__PREDECESSOR));
			if (transientValues.isValueTransient(semanticObject, MoniLogPackage.Literals.PRECEDENCE__SUCCESSOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MoniLogPackage.Literals.PRECEDENCE__SUCCESSOR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPatternAccess().getPredecessorStreamEventParserRuleCall_3_1_0(), semanticObject.getPredecessor());
		feeder.accept(grammarAccess.getPatternAccess().getSuccessorStreamEventParserRuleCall_3_3_0(), semanticObject.getSuccessor());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Pattern returns Response
	 *
	 * Constraint:
	 *     (event=StreamEvent trigger=StreamEvent)
	 */
	protected void sequence_Pattern(ISerializationContext context, Response semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MoniLogPackage.Literals.RESPONSE__EVENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MoniLogPackage.Literals.RESPONSE__EVENT));
			if (transientValues.isValueTransient(semanticObject, MoniLogPackage.Literals.RESPONSE__TRIGGER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MoniLogPackage.Literals.RESPONSE__TRIGGER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPatternAccess().getEventStreamEventParserRuleCall_4_1_0(), semanticObject.getEvent());
		feeder.accept(grammarAccess.getPatternAccess().getTriggerStreamEventParserRuleCall_4_3_0(), semanticObject.getTrigger());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Pattern returns Universality
	 *
	 * Constraint:
	 *     event=StreamEvent
	 */
	protected void sequence_Pattern(ISerializationContext context, Universality semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MoniLogPackage.Literals.UNIVERSALITY__EVENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MoniLogPackage.Literals.UNIVERSALITY__EVENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPatternAccess().getEventStreamEventParserRuleCall_1_2_0(), semanticObject.getEvent());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SimpleExpression returns Minus
	 *     ContractedIf returns Minus
	 *     ContractedIf.ContractedIf_1_0 returns Minus
	 *     Or returns Minus
	 *     Or.Or_1_0 returns Minus
	 *     And returns Minus
	 *     And.And_1_0 returns Minus
	 *     Equality returns Minus
	 *     Equality.Equality_1_0 returns Minus
	 *     Comparison returns Minus
	 *     Comparison.Comparison_1_0 returns Minus
	 *     PlusOrMinus returns Minus
	 *     PlusOrMinus.Plus_1_0_0_0 returns Minus
	 *     PlusOrMinus.Minus_1_0_1_0 returns Minus
	 *
	 * Constraint:
	 *     (left=PlusOrMinus_Minus_1_0_1_0 op='-' right=MulOrDiv)
	 */
	protected void sequence_PlusOrMinus(ISerializationContext context, Minus semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MoniLogPackage.Literals.MINUS__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MoniLogPackage.Literals.MINUS__LEFT));
			if (transientValues.isValueTransient(semanticObject, MoniLogPackage.Literals.MINUS__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MoniLogPackage.Literals.MINUS__OP));
			if (transientValues.isValueTransient(semanticObject, MoniLogPackage.Literals.MINUS__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MoniLogPackage.Literals.MINUS__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPlusOrMinusAccess().getMinusLeftAction_1_0_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getPlusOrMinusAccess().getOpHyphenMinusKeyword_1_0_1_1_0(), semanticObject.getOp());
		feeder.accept(grammarAccess.getPlusOrMinusAccess().getRightMulOrDivParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SimpleExpression returns Plus
	 *     ContractedIf returns Plus
	 *     ContractedIf.ContractedIf_1_0 returns Plus
	 *     Or returns Plus
	 *     Or.Or_1_0 returns Plus
	 *     And returns Plus
	 *     And.And_1_0 returns Plus
	 *     Equality returns Plus
	 *     Equality.Equality_1_0 returns Plus
	 *     Comparison returns Plus
	 *     Comparison.Comparison_1_0 returns Plus
	 *     PlusOrMinus returns Plus
	 *     PlusOrMinus.Plus_1_0_0_0 returns Plus
	 *     PlusOrMinus.Minus_1_0_1_0 returns Plus
	 *
	 * Constraint:
	 *     (left=PlusOrMinus_Plus_1_0_0_0 op='+' right=MulOrDiv)
	 */
	protected void sequence_PlusOrMinus(ISerializationContext context, Plus semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MoniLogPackage.Literals.PLUS__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MoniLogPackage.Literals.PLUS__LEFT));
			if (transientValues.isValueTransient(semanticObject, MoniLogPackage.Literals.PLUS__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MoniLogPackage.Literals.PLUS__OP));
			if (transientValues.isValueTransient(semanticObject, MoniLogPackage.Literals.PLUS__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MoniLogPackage.Literals.PLUS__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPlusOrMinusAccess().getPlusLeftAction_1_0_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getPlusOrMinusAccess().getOpPlusSignKeyword_1_0_0_1_0(), semanticObject.getOp());
		feeder.accept(grammarAccess.getPlusOrMinusAccess().getRightMulOrDivParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SimpleExpression returns Not
	 *     ContractedIf returns Not
	 *     ContractedIf.ContractedIf_1_0 returns Not
	 *     Or returns Not
	 *     Or.Or_1_0 returns Not
	 *     And returns Not
	 *     And.And_1_0 returns Not
	 *     Equality returns Not
	 *     Equality.Equality_1_0 returns Not
	 *     Comparison returns Not
	 *     Comparison.Comparison_1_0 returns Not
	 *     PlusOrMinus returns Not
	 *     PlusOrMinus.Plus_1_0_0_0 returns Not
	 *     PlusOrMinus.Minus_1_0_1_0 returns Not
	 *     MulOrDiv returns Not
	 *     MulOrDiv.Mul_1_0_0_0 returns Not
	 *     MulOrDiv.Div_1_0_1_0 returns Not
	 *     Modulo returns Not
	 *     Modulo.Modulo_1_0 returns Not
	 *     Primary returns Not
	 *
	 * Constraint:
	 *     expression=Primary
	 */
	protected void sequence_Primary(ISerializationContext context, Not semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MoniLogPackage.Literals.NOT__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MoniLogPackage.Literals.NOT__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrimaryAccess().getExpressionPrimaryParserRuleCall_2_2_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SimpleExpression returns Parenthesis
	 *     ContractedIf returns Parenthesis
	 *     ContractedIf.ContractedIf_1_0 returns Parenthesis
	 *     Or returns Parenthesis
	 *     Or.Or_1_0 returns Parenthesis
	 *     And returns Parenthesis
	 *     And.And_1_0 returns Parenthesis
	 *     Equality returns Parenthesis
	 *     Equality.Equality_1_0 returns Parenthesis
	 *     Comparison returns Parenthesis
	 *     Comparison.Comparison_1_0 returns Parenthesis
	 *     PlusOrMinus returns Parenthesis
	 *     PlusOrMinus.Plus_1_0_0_0 returns Parenthesis
	 *     PlusOrMinus.Minus_1_0_1_0 returns Parenthesis
	 *     MulOrDiv returns Parenthesis
	 *     MulOrDiv.Mul_1_0_0_0 returns Parenthesis
	 *     MulOrDiv.Div_1_0_1_0 returns Parenthesis
	 *     Modulo returns Parenthesis
	 *     Modulo.Modulo_1_0 returns Parenthesis
	 *     Primary returns Parenthesis
	 *
	 * Constraint:
	 *     expression=SimpleExpression
	 */
	protected void sequence_Primary(ISerializationContext context, Parenthesis semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MoniLogPackage.Literals.PARENTHESIS__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MoniLogPackage.Literals.PARENTHESIS__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrimaryAccess().getExpressionSimpleExpressionParserRuleCall_0_2_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SimpleExpression returns UnaryMinus
	 *     ContractedIf returns UnaryMinus
	 *     ContractedIf.ContractedIf_1_0 returns UnaryMinus
	 *     Or returns UnaryMinus
	 *     Or.Or_1_0 returns UnaryMinus
	 *     And returns UnaryMinus
	 *     And.And_1_0 returns UnaryMinus
	 *     Equality returns UnaryMinus
	 *     Equality.Equality_1_0 returns UnaryMinus
	 *     Comparison returns UnaryMinus
	 *     Comparison.Comparison_1_0 returns UnaryMinus
	 *     PlusOrMinus returns UnaryMinus
	 *     PlusOrMinus.Plus_1_0_0_0 returns UnaryMinus
	 *     PlusOrMinus.Minus_1_0_1_0 returns UnaryMinus
	 *     MulOrDiv returns UnaryMinus
	 *     MulOrDiv.Mul_1_0_0_0 returns UnaryMinus
	 *     MulOrDiv.Div_1_0_1_0 returns UnaryMinus
	 *     Modulo returns UnaryMinus
	 *     Modulo.Modulo_1_0 returns UnaryMinus
	 *     Primary returns UnaryMinus
	 *
	 * Constraint:
	 *     expression=Primary
	 */
	protected void sequence_Primary(ISerializationContext context, UnaryMinus semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MoniLogPackage.Literals.UNARY_MINUS__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MoniLogPackage.Literals.UNARY_MINUS__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrimaryAccess().getExpressionPrimaryParserRuleCall_1_2_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     EmptyOrPropertyValue returns PropertyValue
	 *     PropertyValue returns PropertyValue
	 *
	 * Constraint:
	 *     ((id=ID value=Expression?) | value=LanguageValue)
	 */
	protected void sequence_PropertyValue(ISerializationContext context, PropertyValue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SimpleExpression returns ArrayRef
	 *     ContractedIf returns ArrayRef
	 *     ContractedIf.ContractedIf_1_0 returns ArrayRef
	 *     Or returns ArrayRef
	 *     Or.Or_1_0 returns ArrayRef
	 *     And returns ArrayRef
	 *     And.And_1_0 returns ArrayRef
	 *     Equality returns ArrayRef
	 *     Equality.Equality_1_0 returns ArrayRef
	 *     Comparison returns ArrayRef
	 *     Comparison.Comparison_1_0 returns ArrayRef
	 *     PlusOrMinus returns ArrayRef
	 *     PlusOrMinus.Plus_1_0_0_0 returns ArrayRef
	 *     PlusOrMinus.Minus_1_0_1_0 returns ArrayRef
	 *     MulOrDiv returns ArrayRef
	 *     MulOrDiv.Mul_1_0_0_0 returns ArrayRef
	 *     MulOrDiv.Div_1_0_1_0 returns ArrayRef
	 *     Modulo returns ArrayRef
	 *     Modulo.Modulo_1_0 returns ArrayRef
	 *     Primary returns ArrayRef
	 *     Atomic returns ArrayRef
	 *     Ref returns ArrayRef
	 *     Ref.ArrayRef_1_0_0 returns ArrayRef
	 *     Ref.PropertyRef_1_1_0 returns ArrayRef
	 *
	 * Constraint:
	 *     (array=Ref_ArrayRef_1_0_0 indices+=SimpleExpression indices+=SimpleExpression*)
	 */
	protected void sequence_Ref(ISerializationContext context, ArrayRef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SimpleExpression returns PropertyRef
	 *     ContractedIf returns PropertyRef
	 *     ContractedIf.ContractedIf_1_0 returns PropertyRef
	 *     Or returns PropertyRef
	 *     Or.Or_1_0 returns PropertyRef
	 *     And returns PropertyRef
	 *     And.And_1_0 returns PropertyRef
	 *     Equality returns PropertyRef
	 *     Equality.Equality_1_0 returns PropertyRef
	 *     Comparison returns PropertyRef
	 *     Comparison.Comparison_1_0 returns PropertyRef
	 *     PlusOrMinus returns PropertyRef
	 *     PlusOrMinus.Plus_1_0_0_0 returns PropertyRef
	 *     PlusOrMinus.Minus_1_0_1_0 returns PropertyRef
	 *     MulOrDiv returns PropertyRef
	 *     MulOrDiv.Mul_1_0_0_0 returns PropertyRef
	 *     MulOrDiv.Div_1_0_1_0 returns PropertyRef
	 *     Modulo returns PropertyRef
	 *     Modulo.Modulo_1_0 returns PropertyRef
	 *     Primary returns PropertyRef
	 *     Atomic returns PropertyRef
	 *     Ref returns PropertyRef
	 *     Ref.ArrayRef_1_0_0 returns PropertyRef
	 *     Ref.PropertyRef_1_1_0 returns PropertyRef
	 *
	 * Constraint:
	 *     (object=Ref_PropertyRef_1_1_0 property=ID)
	 */
	protected void sequence_Ref(ISerializationContext context, PropertyRef semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MoniLogPackage.Literals.PROPERTY_REF__OBJECT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MoniLogPackage.Literals.PROPERTY_REF__OBJECT));
			if (transientValues.isValueTransient(semanticObject, MoniLogPackage.Literals.PROPERTY_REF__PROPERTY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MoniLogPackage.Literals.PROPERTY_REF__PROPERTY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRefAccess().getPropertyRefObjectAction_1_1_0(), semanticObject.getObject());
		feeder.accept(grammarAccess.getRefAccess().getPropertyIDTerminalRuleCall_1_1_2_0(), semanticObject.getProperty());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Scope returns After
	 *
	 * Constraint:
	 *     lowerBound=StreamEvent
	 */
	protected void sequence_Scope(ISerializationContext context, After semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MoniLogPackage.Literals.AFTER__LOWER_BOUND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MoniLogPackage.Literals.AFTER__LOWER_BOUND));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getScopeAccess().getLowerBoundStreamEventParserRuleCall_1_2_0(), semanticObject.getLowerBound());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Scope returns AfterUntil
	 *
	 * Constraint:
	 *     (lowerBound=StreamEvent upperBound=StreamEvent)
	 */
	protected void sequence_Scope(ISerializationContext context, AfterUntil semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MoniLogPackage.Literals.AFTER_UNTIL__LOWER_BOUND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MoniLogPackage.Literals.AFTER_UNTIL__LOWER_BOUND));
			if (transientValues.isValueTransient(semanticObject, MoniLogPackage.Literals.AFTER_UNTIL__UPPER_BOUND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MoniLogPackage.Literals.AFTER_UNTIL__UPPER_BOUND));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getScopeAccess().getLowerBoundStreamEventParserRuleCall_4_2_0(), semanticObject.getLowerBound());
		feeder.accept(grammarAccess.getScopeAccess().getUpperBoundStreamEventParserRuleCall_4_4_0(), semanticObject.getUpperBound());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Scope returns Before
	 *
	 * Constraint:
	 *     upperBound=StreamEvent
	 */
	protected void sequence_Scope(ISerializationContext context, Before semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MoniLogPackage.Literals.BEFORE__UPPER_BOUND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MoniLogPackage.Literals.BEFORE__UPPER_BOUND));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getScopeAccess().getUpperBoundStreamEventParserRuleCall_2_2_0(), semanticObject.getUpperBound());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Scope returns Between
	 *
	 * Constraint:
	 *     (lowerBound=StreamEvent upperBound=StreamEvent)
	 */
	protected void sequence_Scope(ISerializationContext context, Between semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MoniLogPackage.Literals.BETWEEN__LOWER_BOUND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MoniLogPackage.Literals.BETWEEN__LOWER_BOUND));
			if (transientValues.isValueTransient(semanticObject, MoniLogPackage.Literals.BETWEEN__UPPER_BOUND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MoniLogPackage.Literals.BETWEEN__UPPER_BOUND));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getScopeAccess().getLowerBoundStreamEventParserRuleCall_3_2_0(), semanticObject.getLowerBound());
		feeder.accept(grammarAccess.getScopeAccess().getUpperBoundStreamEventParserRuleCall_3_4_0(), semanticObject.getUpperBound());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Scope returns Globally
	 *
	 * Constraint:
	 *     {Globally}
	 */
	protected void sequence_Scope(ISerializationContext context, Globally semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SimpleExpression returns SimpleVarRef
	 *     ContractedIf returns SimpleVarRef
	 *     ContractedIf.ContractedIf_1_0 returns SimpleVarRef
	 *     Or returns SimpleVarRef
	 *     Or.Or_1_0 returns SimpleVarRef
	 *     And returns SimpleVarRef
	 *     And.And_1_0 returns SimpleVarRef
	 *     Equality returns SimpleVarRef
	 *     Equality.Equality_1_0 returns SimpleVarRef
	 *     Comparison returns SimpleVarRef
	 *     Comparison.Comparison_1_0 returns SimpleVarRef
	 *     PlusOrMinus returns SimpleVarRef
	 *     PlusOrMinus.Plus_1_0_0_0 returns SimpleVarRef
	 *     PlusOrMinus.Minus_1_0_1_0 returns SimpleVarRef
	 *     MulOrDiv returns SimpleVarRef
	 *     MulOrDiv.Mul_1_0_0_0 returns SimpleVarRef
	 *     MulOrDiv.Div_1_0_1_0 returns SimpleVarRef
	 *     Modulo returns SimpleVarRef
	 *     Modulo.Modulo_1_0 returns SimpleVarRef
	 *     Primary returns SimpleVarRef
	 *     Atomic returns SimpleVarRef
	 *     Ref returns SimpleVarRef
	 *     Ref.ArrayRef_1_0_0 returns SimpleVarRef
	 *     Ref.PropertyRef_1_1_0 returns SimpleVarRef
	 *     SimpleVarRef returns SimpleVarRef
	 *
	 * Constraint:
	 *     target=ID
	 */
	protected void sequence_SimpleVarRef(ISerializationContext context, SimpleVarRef semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MoniLogPackage.Literals.SIMPLE_VAR_REF__TARGET) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MoniLogPackage.Literals.SIMPLE_VAR_REF__TARGET));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSimpleVarRefAccess().getTargetIDTerminalRuleCall_0(), semanticObject.getTarget());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     StreamEvent returns StreamEvent
	 *
	 * Constraint:
	 *     (event=[Event|ID] (values+=EmptyOrPropertyValue values+=EmptyOrPropertyValue*)?)
	 */
	protected void sequence_StreamEvent(ISerializationContext context, StreamEvent semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TemporalPattern returns TemporalPattern
	 *
	 * Constraint:
	 *     (pattern=Pattern scope=Scope)
	 */
	protected void sequence_TemporalPattern(ISerializationContext context, TemporalPattern semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MoniLogPackage.Literals.TEMPORAL_PATTERN__PATTERN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MoniLogPackage.Literals.TEMPORAL_PATTERN__PATTERN));
			if (transientValues.isValueTransient(semanticObject, MoniLogPackage.Literals.TEMPORAL_PATTERN__SCOPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MoniLogPackage.Literals.TEMPORAL_PATTERN__SCOPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTemporalPatternAccess().getPatternPatternParserRuleCall_0_0(), semanticObject.getPattern());
		feeder.accept(grammarAccess.getTemporalPatternAccess().getScopeScopeParserRuleCall_1_0(), semanticObject.getScope());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     BoundType returns UpperBound
	 *     UpperBound returns UpperBound
	 *
	 * Constraint:
	 *     n=INT
	 */
	protected void sequence_UpperBound(ISerializationContext context, UpperBound semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MoniLogPackage.Literals.BOUND_TYPE__N) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MoniLogPackage.Literals.BOUND_TYPE__N));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUpperBoundAccess().getNINTTerminalRuleCall_1_0(), semanticObject.getN());
		feeder.finish();
	}
	
	
}
